<!doctype html><html lang=en><head><script async defer data-website-id=08a754c4-6690-46d7-bb80-8ff93cfa232f src=https://umami.oldwinter.top/umami.js></script><meta charset=utf-8><meta name=description content="为什么说synchronized是重量级锁？ 我们知道，cpu会运行在用户态和内核态。如[[零拷贝]]就是为了减少在用户态的运行。[[synchronized]]效率低， 是因为synchronized是跑在jvm上，需要对操作系统进行申请资源。
在java中很多实现中, 很多都是轻量级锁, 比如JUC中的CAS. 所谓的轻量级锁和重量级锁的区别是什么呢? 轻量级锁都是在用户态直接完成, 不用惊动操作系统, 而重量级锁需要向操作系统申请. 在现在synchronized内部的执行过程中, 他会首先使用轻量级锁, 在用户态中完成, 如果完成不了才会去申请重量级锁, 即内核态的锁, 这就是synchronized的升级过程
 跑在jvm上，会有资源损坏。比如dubbo的[[直接内存|堆外内存]]实现，就是为了减少jvm到c的heap的损坏。
 锁的对象是什么？  [!"><title>资料</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" type=image/png href=https://clickear.github.io//icon.png><link href=https://clickear.github.io/styles.b3e1e36b0403ac565c9392b3e23ef3b6.min.css rel=stylesheet><link href=https://clickear.github.io/styles/_light_syntax.86a48a52faebeaaf42158b72922b1c90.min.css rel=stylesheet id=theme-link><script src=https://clickear.github.io/js/darkmode.b3f60b41d3bdcb2b37845d5bbe5bdf9e.min.js></script>
<script src=https://clickear.github.io/js/util.9825137f5e7825e8553c68ce39ac9e44.min.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css integrity=sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js integrity=sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script>
<script src=https://unpkg.com/@floating-ui/core@0.7.3></script>
<script src=https://unpkg.com/@floating-ui/dom@0.5.4></script>
<script src=https://clickear.github.io/js/popover.abe6a51cc7138c5dff00f151dd627ad1.min.js></script>
<script src=https://clickear.github.io/js/code-title.b35124ad8db0ba37162b886afb711cbc.min.js></script>
<script src=https://clickear.github.io/js/clipboard.c20857734e53a3fb733b7443879efa61.min.js></script>
<script src=https://clickear.github.io/js/callouts.7723cac461d613d118ee8bb8216b9838.min.js></script>
<script>const BASE_URL="https://clickear.github.io/",fetchData=Promise.all([fetch("https://clickear.github.io/indices/linkIndex.4ae3a1c8dbfcee2ead7ac0bbd17e436b.min.json").then(e=>e.json()).then(e=>({index:e.index,links:e.links})),fetch("https://clickear.github.io/indices/contentIndex.e5c08b6c8326b4c09a7f9df802b6d68a.min.json").then(e=>e.json())]).then(([{index:e,links:t},n])=>({index:e,links:t,content:n})),render=()=>{const e=new URL(BASE_URL),t=e.pathname,n=window.location.pathname,s=t==n;addCopyButtons(),addCollapsibleCallouts(),initPopover("https://clickear.github.io",!0,!0);const o=document.getElementById("footer");if(o){const e=document.getElementById("graph-container");if(!e)return requestAnimationFrame(render);e.textContent="";const t=s&&!1;drawGraph("https://clickear.github.io",t,[{"/moc":"#4388cc"}],t?{centerForce:1,depth:-1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.5,linkDistance:1,opacityScale:3,repelForce:1,scale:1.4}:{centerForce:1,depth:1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.6,linkDistance:1,opacityScale:3,repelForce:2,scale:1.2})}},init=(e=document)=>{addCopyButtons(),addTitleToCodeBlocks(),renderMathInElement(e.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],throwOnError:!1})}</script><script>window.Million={navigate:e=>window.location.href=e,prefetch:()=>{}},window.addEventListener("DOMContentLoaded",()=>{init(),render()})</script></head><script async src="https://www.googletagmanager.com/gtag/js?id=G-11MD77L81V"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-11MD77L81V",{anonymize_ip:!1})}</script><body><div id=search-container><div id=search-space><input autocomplete=off id=search-bar name=search type=text aria-label="search any" placeholder=支持标题及全文搜索...><div id=results-container></div></div></div><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.21/dist/flexsearch.bundle.js integrity="sha256-i3A0NZGkhsKjVMzFxv3ksk0DZh3aXqu0l49Bbh0MdjE=" crossorigin=anonymous defer></script>
<script defer src=https://clickear.github.io/js/full-text-search.24827f874defbbc6d529926cbfcfb493.min.js></script><div class=singlePage><header><h1 id=page-title><a href=https://clickear.github.io/>🌿 clickearの数字花园</a></h1><div class=spacer></div><div id=search-icon><p>search any</p><svg tabindex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search Icon</title><desc id="desc">Icon to open search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"/><circle cx="8" cy="8" r="7"/></g></svg></div><div class=darkmode><input class=toggle id=darkmode-toggle type=checkbox tabindex=-1>
<label id=toggle-label-light for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="dayIcon" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35"><title>Light Mode</title><path d="M6 17.5C6 16.672 5.328 16 4.5 16h-3C.672 16 0 16.672.0 17.5S.672 19 1.5 19h3C5.328 19 6 18.328 6 17.5zM7.5 26c-.414.0-.789.168-1.061.439l-2 2C4.168 28.711 4 29.086 4 29.5 4 30.328 4.671 31 5.5 31c.414.0.789-.168 1.06-.44l2-2C8.832 28.289 9 27.914 9 27.5 9 26.672 8.329 26 7.5 26zm10-20C18.329 6 19 5.328 19 4.5v-3C19 .672 18.329.0 17.5.0S16 .672 16 1.5v3C16 5.328 16.671 6 17.5 6zm10 3c.414.0.789-.168 1.06-.439l2-2C30.832 6.289 31 5.914 31 5.5 31 4.672 30.329 4 29.5 4c-.414.0-.789.168-1.061.44l-2 2C26.168 6.711 26 7.086 26 7.5 26 8.328 26.671 9 27.5 9zM6.439 8.561C6.711 8.832 7.086 9 7.5 9 8.328 9 9 8.328 9 7.5c0-.414-.168-.789-.439-1.061l-2-2C6.289 4.168 5.914 4 5.5 4 4.672 4 4 4.672 4 5.5c0 .414.168.789.439 1.06l2 2.001zM33.5 16h-3c-.828.0-1.5.672-1.5 1.5s.672 1.5 1.5 1.5h3c.828.0 1.5-.672 1.5-1.5S34.328 16 33.5 16zM28.561 26.439C28.289 26.168 27.914 26 27.5 26c-.828.0-1.5.672-1.5 1.5.0.414.168.789.439 1.06l2 2C28.711 30.832 29.086 31 29.5 31c.828.0 1.5-.672 1.5-1.5.0-.414-.168-.789-.439-1.061l-2-2zM17.5 29c-.829.0-1.5.672-1.5 1.5v3c0 .828.671 1.5 1.5 1.5s1.5-.672 1.5-1.5v-3C19 29.672 18.329 29 17.5 29zm0-22C11.71 7 7 11.71 7 17.5S11.71 28 17.5 28 28 23.29 28 17.5 23.29 7 17.5 7zm0 18c-4.136.0-7.5-3.364-7.5-7.5s3.364-7.5 7.5-7.5 7.5 3.364 7.5 7.5S21.636 25 17.5 25z"/></svg></label><label id=toggle-label-dark for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="nightIcon" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'"><title>Dark Mode</title><path d="M96.76 66.458c-.853-.852-2.15-1.064-3.23-.534-6.063 2.991-12.858 4.571-19.655 4.571C62.022 70.495 50.88 65.88 42.5 57.5 29.043 44.043 25.658 23.536 34.076 6.47c.532-1.08.318-2.379-.534-3.23-.851-.852-2.15-1.064-3.23-.534-4.918 2.427-9.375 5.619-13.246 9.491-9.447 9.447-14.65 22.008-14.65 35.369.0 13.36 5.203 25.921 14.65 35.368s22.008 14.65 35.368 14.65c13.361.0 25.921-5.203 35.369-14.65 3.872-3.871 7.064-8.328 9.491-13.246C97.826 68.608 97.611 67.309 96.76 66.458z"/></svg></label></div></header><article><h1>资料</h1><p class=meta>最近编辑于
Sep 26, 2022</p><ul class=tags></ul><aside class=mainTOC><details open><summary>目录</summary><nav id=TableOfContents><ol><li><a href=#为什么说synchronized是重量级锁>为什么说synchronized是重量级锁？</a></li><li><a href=#锁的对象是什么>锁的对象是什么？</a></li><li><a href=#synchronized的实现原理重量级锁的原理>[[synchronized]]的实现原理(重量级锁的原理)</a></li><li><a href=#锁升级>锁升级</a><ol><li><a href=#偏向锁仅一个线程对象头存线程id>偏向锁(仅一个线程，对象头存线程id)</a></li><li><a href=#轻量级锁多线程交替进入临界区自旋对象头存lock-record指针>轻量级锁（多线程交替进入临界区，自旋，对象头存Lock Record指针，）</a></li><li><a href=#重量级锁多线程存的是monitor的指针>重量级锁(多线程，存的是Monitor的指针)</a></li><li><a href=#对比>对比</a></li></ol></li><li><a href=#hashcode哪里去了>hashcode哪里去了？</a></li><li><a href=#wait为什么需要释放锁>wait为什么需要释放锁？</a></li><li><a href=#wait和notify存在问题>wait和notify存在问题</a></li></ol></nav></details></aside><a href=#为什么说synchronized是重量级锁><h2 id=为什么说synchronized是重量级锁><span class=hanchor arialabel=Anchor># </span>为什么说synchronized是重量级锁？</h2></a><p>我们知道，cpu会运行在用户态和内核态。如<a href=/%E9%9B%B6%E6%8B%B7%E8%B4%9D rel=noopener class=internal-link data-src=/%E9%9B%B6%E6%8B%B7%E8%B4%9D>零拷贝</a>就是为了减少在用户态的运行。<a href=/synchronized rel=noopener class=internal-link data-src=/synchronized>synchronized</a>效率低， 是因为synchronized是跑在jvm上，需要对操作系统进行申请资源。<br>在java中很多实现中, 很多都是轻量级锁, 比如JUC中的CAS. 所谓的轻量级锁和重量级锁的区别是什么呢? 轻量级锁都是在<strong>用户态直接完成</strong>, 不用惊动操作系统, 而重量级锁需要<strong>向操作系统申请</strong>. 在现在synchronized内部的执行过程中, 他会首先使用轻量级锁, 在用户态中完成, 如果完成不了才会去申请重量级锁, 即内核态的锁, 这就是synchronized的<strong>升级</strong>过程</p><blockquote><p>跑在jvm上，会有资源损坏。比如dubbo的<a href=/%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98 rel=noopener class=internal-link data-src=/%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98>堆外内存</a>实现，就是为了减少jvm到c的heap的损坏。</p></blockquote><a href=#锁的对象是什么><h2 id=锁的对象是什么><span class=hanchor arialabel=Anchor># </span>锁的对象是什么？</h2></a><blockquote class=tip-callout><p>技巧💡<br>本质上，是给某个对象加了锁。</p></blockquote><ol><li>修饰实例方法，对当前实例对象this加锁</li><li>修饰静态方法，对当前类的Class对象加锁。Class对象，在jvm中也是一个对象。</li><li>修饰代码块，指定加锁对象，对给定对象加锁</li></ol><a href=#synchronized的实现原理重量级锁的原理><h2 id=synchronized的实现原理重量级锁的原理><span class=hanchor arialabel=Anchor># </span><a href=/synchronized rel=noopener class=internal-link data-src=/synchronized>synchronized</a>的实现原理(重量级锁的原理)</h2></a><p>在<a href=/%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E5%B8%83%E5%B1%80 rel=noopener class=internal-link data-src=/%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E5%B8%83%E5%B1%80>对象存储布局</a>中可知，一个对象的内存布局方式。<br><img src=http://image.clickear.top/20220926104914.png width=auto alt></p><p>重量级锁也就是通常说synchronized的对象锁，锁标识位为10，其中指针指向的是monitor对象（也称为管程或监视器锁）的起始地址。每个对象都存在着一个 monitor 与之关联。在Java虚拟机(HotSpot)中，monitor是由ObjectMonitor实现的，其主要数据结构如下（位于HotSpot虚拟机源码ObjectMonitor.hpp文件，C++实现的），省略部分属性</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>ObjectMonitor</span><span class=o>()</span> <span class=o>{</span>  
</span></span><span class=line><span class=cl>    <span class=n>_count</span> <span class=o>=</span> <span class=n>0</span><span class=o>;</span> <span class=c1>//记录数  
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>_recursions</span> <span class=o>=</span> <span class=n>0</span><span class=o>;</span> <span class=c1>//锁的重入次数  
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>_owner</span> <span class=o>=</span> <span class=n>NULL</span><span class=o>;</span> <span class=c1>//指向持有ObjectMonitor对象的线程  
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>_WaitSet</span> <span class=o>=</span> <span class=n>NULL</span><span class=o>;</span> <span class=c1>//调用wait后，线程会被加入到_WaitSet  
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>_EntryList</span> <span class=o>=</span> <span class=n>NULL</span> <span class=o>;</span> <span class=c1>//等待获取锁的线程，会被加入到该列表  
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=o>}</span>
</span></span></code></pre></td></tr></table></div></div><blockquote class=note-callout><p>笔记</p><ol><li>可以这么理解，如果是重量级锁，每个对象头指向的是监视器的指针，这个monitor每个对象都有一个与之关联。</li><li>每个monitor，包含了<br>同步队列(entryList)，即是都需要竞争抢资源的线程列表。<br>当前线程，owner<br>等待队列，即调用wait之后，会被放到等待队列。在被调用notify或者notifyAll时，会移动到同步队列中，重新竞争。</li></ol></blockquote><p><img src=http://image.clickear.top/20220926110229.png width=auto alt></p><a href=#锁升级><h2 id=锁升级><span class=hanchor arialabel=Anchor># </span>锁升级</h2></a><p><img src=http://image.clickear.top/20220926115625.png width=auto alt></p><blockquote class=note-callout><p>笔记<br>synchronized锁升级过程总结：<strong>一句话，就是先自旋，不行再阻塞</strong>。</p><p>实际上是把之前的悲观锁(重量级锁)变成在一定条件下使用偏向锁以及使用轻量级(自旋锁CAS)的形式</p><p>synchronized在修饰方法和代码块在字节码上实现方式有很大差异，但是内部实现还是基于对象头的MarkWord来实现的。 JDK1.6之前synchronized使用的是重量级锁，<strong>JDK1.6之后进行了优化，拥有了无锁->偏向锁->轻量级锁->重量级锁的升级过程</strong>，而不是无论什么情况都使用重量级锁。</p><ul><li><strong>偏向锁</strong>：适用于单线程适用的情况，在不存在锁竞争的时候进入同步方法/代码块则使用偏向锁。</li><li><strong>轻量级锁</strong>：适用于竞争较不激烈的情况(这和乐观锁的使用范围类似)， 存在竞争时升级为轻量级锁，轻量级锁采用的是自旋锁，如果同步方法/代码块执行时间很短的话，采用轻量级锁虽然会占用cpu资源但是相对比使用重量级锁还是更高效。</li><li><strong>重量级锁</strong>：适用于竞争激烈的情况，如果同步方法/代码块执行时间很长，那么使用轻量级锁自旋带来的性能消耗就比使用重量级锁更严重，这时候就需要升级为重量级锁。</li></ul></blockquote><ul><li>偏向锁：Mark Word_存储的是偏向的<strong>线程ID</strong>。有且只有<strong>一个线程</strong>来访问。</li><li>轻量锁：Mark Word_存储的是指向线程中_Lock Record_的指针。<strong>有多个线程A、B来交替访问</strong></li><li>重量：Mark Word_存储的是指向堆中_Monitor_对象的指针。**竞争激烈，多个线程来访问</li></ul><p><img src=http://image.clickear.top/20220926112300.png width=auto alt></p><p><img src=http://image.clickear.top/20220926112939.png width=auto alt></p><blockquote class=note-callout><p>升级过程。</p><ol><li>首次访问，直接使用偏向锁。将线程id保存在对象头中，下次要锁时，直接进行判断。</li><li>如果有其它线程访问，尝试CAS来替换线程id，如果原来线程存在，则升级为轻量级锁。</li></ol></blockquote><a href=#偏向锁仅一个线程对象头存线程id><h3 id=偏向锁仅一个线程对象头存线程id><span class=hanchor arialabel=Anchor># </span>偏向锁(仅一个线程，对象头存线程id)</h3></a><ul><li>当一段同步代码一直被同一个线程多次访问，由于只有一个线程那么该线程在后续访问时便会自动获得锁</li><li>同一个老顾客来访，直接老规矩行方便.</li></ul><p>只需要在锁第一次被拥有的时候，记录下偏向线程ID。这样偏向线程就一直持有着锁(后续这个线程进入和退出这段加了同步锁的代码块时，**不需要再次加锁和释放锁。**而是直接比较对象头里面是否存储了指向当前线程的ID(<em>偏向锁</em>))。</p><ul><li><strong>如果相等</strong>表示偏向锁是偏向于当前线程的，就不需要再尝试获得锁了，直到竞争发生才释放锁。以后每次同步，检查锁的偏向线程ID与当前线程ID是否一致，如果一致直接进入同步。无需每次加锁解锁都去CAS更新对象头。<em><strong>如果自始至终使用锁的线程只有一个</strong></em>，很明显偏向锁几乎没有额外开销，性能极高。</li><li><strong>如果不相等</strong>意味着发生了竞争，锁已经不是总是偏向于同一个线程了，这个时候会尝试使用CAS来替换MarkWord里面的线程ID为新的线程ID<ul><li><strong>竞争成功</strong>：表示之前的线程不存在了，MarkWord里面的线程ID为新的线程ID，锁不会升级，仍为偏向锁</li><li><strong>竞争失败</strong>：这时候可能需要升级变为轻量级锁，才能保证线程间公平竞争锁。</li></ul></li></ul><a href=#轻量级锁多线程交替进入临界区自旋对象头存lock-record指针><h3 id=轻量级锁多线程交替进入临界区自旋对象头存lock-record指针><span class=hanchor arialabel=Anchor># </span>轻量级锁（多线程交替进入临界区，自旋，对象头存Lock Record指针，）</h3></a><p>有线程来参与锁的竞争，但是获取锁的冲突时间极短，<strong>本质就是自旋锁</strong><br>在没有多线程竞争的前提下，<strong>通过CAS减少</strong>重量级锁使用操作系统互斥量产生的性能消耗，<strong>说白了先自旋再阻塞</strong>。</p><p>JVM会为每个线程在当前线程的栈帧中创建用于存储锁记录的空间，官方成为<code>Displaced Mark Word</code>。若一个线程获得锁时发现是轻量级锁，会把锁的MarkWord复制到自己的Displaced Mark Word里面。然后线程尝试用CAS将锁的MarkWord替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示Mark Word已经被替换成了其他线程的锁记录，说明在与其它线程竞争锁，当前线程就尝试使用自旋来获取锁。</p><ul><li>争夺轻量级锁失败时，自旋尝试抢占锁。</li></ul><a href=#重量级锁多线程存的是monitor的指针><h3 id=重量级锁多线程存的是monitor的指针><span class=hanchor arialabel=Anchor># </span>重量级锁(多线程，存的是Monitor的指针)</h3></a><p>Java中synchronizedi的重量级锁，是基于进入和退出Monitor>对象实现的。在编译时会将同步块的开始位置插入monitor enter指令，在结束位置插入monitor exit指令。<br>当线程执行到monitor enter指令时，会尝试获取对象所对应的Monitor所有权，如果获取到了，即获取到了锁，会在Monitor的owner中存放当前线程的id,这样它将处于锁定状态，除非退出同步块，否则其他线程无法获取到这个Monitor。</p><a href=#对比><h3 id=对比><span class=hanchor arialabel=Anchor># </span>对比</h3></a><table><thead><tr><th style=text-align:center>锁</th><th style=text-align:center>优点</th><th style=text-align:center>缺点</th><th style=text-align:center>适用场景</th></tr></thead><tbody><tr><td style=text-align:center>偏向锁</td><td style=text-align:center>加锁和解锁不需要额外的消耗，和执行非同步方法相比仅存在纳秒级的差距</td><td style=text-align:center>如果线程间存在锁竞争，会带来额外的锁撤销的消耗</td><td style=text-align:center>适用于有一个线程访问同步块场景</td></tr><tr><td style=text-align:center>轻量级锁</td><td style=text-align:center>竞争的线程不会阻塞，提高了程序的响应速度</td><td style=text-align:center>如果始终得不到锁竞争的线程，使用自旋会消耗CPU</td><td style=text-align:center>追求响应时间，同步块执行速度非常快</td></tr><tr><td style=text-align:center>重量级锁</td><td style=text-align:center>线程竞争不使用自旋，不会消耗CPU</td><td style=text-align:center>线程阻塞，响应时间缓慢</td><td style=text-align:center>追求吞吐量、同步块执行速度较长</td></tr></tbody></table><a href=#hashcode哪里去了><h2 id=hashcode哪里去了><span class=hanchor arialabel=Anchor># </span>hashcode哪里去了？</h2></a><blockquote class=note-callout><p>笔记<br>首先，hashcode是在调用hashcode()方法时，才会生成，即惰性生成。而不是在new时，就创建好。</p></blockquote><ul><li><strong>在无锁状态下</strong>，Mark Word中可以存储对象的identity hash code值。当对象的hashCode()方法第一次被调用时，JVM会生成对应的identity hash code值并将该值存储到Mark Word中。</li><li><strong>对于偏向锁</strong>，在线程获取偏向锁时，会用Thread ID和epoch值覆盖identity hash code所在的位置。如果一个对象的hashCode()方法己经被调用过一次之后，这个对象不能被设置偏向锁。因为如果可以的化，那Mark Word中的identity hash code必然会被偏向线程ld给覆盖，这就会造成同一个对象前后两次调用hashCode()方法得到的结果不一致。</li><li><strong>升级为轻量级锁时</strong>，JVM会在当前线程的栈帧中创建一个锁记录(Lock Record)空间，用于存储锁对象的Mark Word拷贝，该拷贝中可以包含identity hash code,所以<strong>轻量级锁可以和identity hash code共存</strong>，哈希码和GC年龄自然保存在此，释放锁后会将这些信息写回到对象头。</li><li><strong>升级为重量级锁后</strong>，Mark Word保存的重量级锁指针代表重量级锁的ObjectMonitor类里有字段记录非加锁状态下的Mark Word,锁释放后也会将信息写回到对象头。</li></ul><p>偏向锁之前，已经调用过hashcode方法，只能升级到 轻量级锁。<br>在已偏向的线程中，调用hashcode方法，会升级成 重量级锁。不知道为什么不是轻量级锁，可能已偏向升级到轻量级成本很高？</p><a href=#wait为什么需要释放锁><h2 id=wait为什么需要释放锁><span class=hanchor arialabel=Anchor># </span>wait为什么需要释放锁？</h2></a><p>当线程A调用<a href=/synchronized rel=noopener class=internal-link data-src=/synchronized>synchronized</a>方法，锁对象。如果调用wait时，不释放锁，进入阻塞状态的话，其它线程就无法进入到<a href=/synchronized rel=noopener class=internal-link data-src=/synchronized>synchronized</a>代码块了，无法调用notify方法，此时线程A无法被唤醒。<br>wait的实现伪代码</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>wait(){
</span></span><span class=line><span class=cl>// 释放锁
</span></span><span class=line><span class=cl>// 阻塞，等待被其它线程notify
</span></span><span class=line><span class=cl>// 重新拿锁。
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><a href=#wait和notify存在问题><h2 id=wait和notify存在问题><span class=hanchor arialabel=Anchor># </span>wait和notify存在问题</h2></a><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kt>void</span> <span class=nf>enqueue</span><span class=o>(){</span>
</span></span><span class=line><span class=cl>	<span class=kd>synchronized</span><span class=o>(</span><span class=n>queue</span><span class=o>){</span>
</span></span><span class=line><span class=cl>		<span class=k>while</span><span class=o>(</span><span class=n>queue</span><span class=o>.</span><span class=na>full</span><span class=o>())</span> <span class=n>queue</span><span class=o>.</span><span class=na>wait</span><span class=o>();</span>
</span></span><span class=line><span class=cl>		<span class=c1>// .... 入队列
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=n>queue</span><span class=o>.</span><span class=na>notify</span><span class=o>();</span><span class=c1>// 通知消费者，队列中有数据
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kt>void</span> <span class=nf>dequeue</span><span class=o>(){</span>
</span></span><span class=line><span class=cl>	<span class=kd>synchronized</span><span class=o>(</span><span class=n>queue</span><span class=o>){</span>
</span></span><span class=line><span class=cl>			<span class=k>while</span><span class=o>(</span><span class=n>queue</span><span class=o>.</span><span class=na>empty</span><span class=o>())</span> <span class=n>queue</span><span class=o>.</span><span class=na>wait</span><span class=o>();</span>
</span></span><span class=line><span class=cl>			<span class=c1>// 。。。。 出队列
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=n>queue</span><span class=o>.</span><span class=na>notify</span><span class=o>();</span><span class=c1>// 通知生产者，队列有空位，可以放了。
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></td></tr></table></div></div><p>这里有个明显问题，就是wait和notify使用的是同一个对象，无法区分队列满和空2个条件。会导致生产者原本只想通知消费者，但它把其它生产者也通知了。<br>这正是condition要解决的。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=n>Lock</span> <span class=n>lock</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ReentrantLock</span><span class=o>();</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=n>Condition</span> <span class=n>notEmpty</span> <span class=o>=</span> <span class=n>lock</span><span class=o>.</span><span class=na>newCondition</span><span class=o>();</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=n>Condition</span> <span class=n>notFull</span> <span class=o>=</span> <span class=n>lock</span><span class=o>.</span><span class=na>newCondition</span><span class=o>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kt>void</span> <span class=nf>enqueue</span><span class=o>(){</span>
</span></span><span class=line><span class=cl>	<span class=n>lock</span><span class=o>.</span><span class=na>lockInterruptibly</span><span class=o>();</span>
</span></span><span class=line><span class=cl>	<span class=k>while</span><span class=o>(</span><span class=n>queue</span><span class=o>.</span><span class=na>full</span><span class=o>()){</span>
</span></span><span class=line><span class=cl>		 <span class=n>notFull</span><span class=o>.</span><span class=na>await</span><span class=o>();</span><span class=c1>// put的时候队列满了。
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=o>}</span>
</span></span><span class=line><span class=cl>		<span class=c1>// .... 入队列
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=n>notEmpty</span><span class=o>.</span><span class=na>signal</span><span class=o>();</span><span class=c1>// 通知消费者，队列中有数据
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kt>void</span> <span class=nf>dequeue</span><span class=o>(){</span>
</span></span><span class=line><span class=cl>	<span class=kd>synchronized</span><span class=o>(</span><span class=n>queue</span><span class=o>){</span>
</span></span><span class=line><span class=cl>			<span class=k>while</span><span class=o>(</span><span class=n>queue</span><span class=o>.</span><span class=na>empty</span><span class=o>())</span> <span class=n>notEmptry</span><span class=o>.</span><span class=na>wait</span><span class=o>();</span>
</span></span><span class=line><span class=cl>			<span class=c1>// 。。。。 出队列
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=n>notFull</span><span class=o>.</span><span class=na>signal</span><span class=o>();</span><span class=c1>// 通知生产者，队列有空位，可以放了。
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></td></tr></table></div></div><a href=#资料><h1 id=资料><span class=hanchor arialabel=Anchor># </span>资料</h1></a><p><a href=https://www.javashitang.com/md/concurrent/Synchronized%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%EF%BC%8C%E9%94%81%E5%8D%87%E7%BA%A7%E5%8E%9F%E7%90%86.html rel=noopener>Synchronized底层实现，锁升级原理 | Java识堂</a><br><a href=https://xiaoyu72.com/articles/b04bf8ad/ rel=noopener>Synchronized与锁升级 - YuBlog</a></p></article><hr><div class=page-end id=footer><div class=backlinks-container><h3>反向链接</h3><ul class=backlinks><li><a href=/%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81/ data-ctx=synchronized data-src=/%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81 class=internal-link>非公平锁</a></li><li><a href=/-%E5%B9%B6%E5%8F%91/ data-ctx=synchronized data-src=/-%E5%B9%B6%E5%8F%91 class=internal-link>∑ 并发</a></li><li><a href=/CAS/ data-ctx=synchronized data-src=/CAS class=internal-link>CAS</a></li><li><a href=/synchronized/ data-ctx=synchronized data-src=/synchronized class=internal-link>资料</a></li></ul></div><div><script src=https://cdn.jsdelivr.net/npm/d3@6.7.0/dist/d3.min.js integrity="sha256-+7jaYCp29O1JusNWHaYtgUn6EhuP0VaFuswhNV06MyI=" crossorigin=anonymous></script><h3>内部链接关系图</h3><div id=graph-container></div><style>:root{--g-node:var(--secondary);--g-node-active:var(--primary);--g-node-inactive:var(--visited);--g-link:var(--outlinegray);--g-link-active:#5a7282}</style><script src=https://clickear.github.io/js/graph.abd4bc2af3869a96524d7d23b76152c7.js></script></div></div><hr><script src=https://giscus.app/client.js data-repo=clickear/knowledge-garden data-repo-id=R_kgDOHT-NGQ data-category=主发布站的评论系统 data-category-id=DIC_kwDOHT-NGc4CQ7hg data-mapping=title data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=zh-CN crossorigin=anonymous async></script></div></body></html>