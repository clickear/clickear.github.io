<!doctype html><html lang=en><head><script async defer data-website-id=08a754c4-6690-46d7-bb80-8ff93cfa232f src=https://umami.oldwinter.top/umami.js></script><meta charset=utf-8><meta name=description content="#分布式
link: 凤凰架构
待办列表   分布式算法-极客时间  常青笔记  分布式写一致性级别（All、[[Quorum机制]]、One、Any） [[多副本]]是分布式中的重要问题，本质上分布式就是解决[[多副本]]的同步问题、共识问题。 [[数据同步]]是直接同步原始数据，状态转移。以同步为代表的数据复制方法。需要每个节点都参与同步，导致可用性太差。 主流做法，是操作转移。类型react中的增量操作。分布式一致性的解决方案是[[状态机复制]]来达到的。 [[Quorum机制]] ([[多数派]])：分布式节点多余一半完成了状态转换，就认为存储成功。  分布2式算法种类  [[拜占庭问题]] 一般而言，在可信环境（比如企业内网）中，系统具有故障容错能力就可以了，常见的算法有二阶段提交协议（2PC）、TCC（Try-Confirm-Cancel）、Paxos 算法、ZAB 协议、Raft 算法、Gossip 协议、Quorum NWR 算法。而在不可信的环境（比如有人做恶）中，这时系统需要具备拜占庭容错能力，"><title>分布2式算法种类</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" type=image/png href=https://clickear.github.io/dg3/icon.png><link href=https://clickear.github.io/dg3/styles.b3e1e36b0403ac565c9392b3e23ef3b6.min.css rel=stylesheet><link href=https://clickear.github.io/dg3/styles/_light_syntax.86a48a52faebeaaf42158b72922b1c90.min.css rel=stylesheet id=theme-link><script src=https://clickear.github.io/dg3/js/darkmode.d332a3e19329b48801bd480fcbca2dc3.min.js></script>
<script src=https://clickear.github.io/dg3/js/util.9825137f5e7825e8553c68ce39ac9e44.min.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css integrity=sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js integrity=sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script>
<script src=https://unpkg.com/@floating-ui/core@0.7.3></script>
<script src=https://unpkg.com/@floating-ui/dom@0.5.4></script>
<script src=https://clickear.github.io/dg3/js/popover.abe6a51cc7138c5dff00f151dd627ad1.min.js></script>
<script src=https://clickear.github.io/dg3/js/code-title.b35124ad8db0ba37162b886afb711cbc.min.js></script>
<script src=https://clickear.github.io/dg3/js/clipboard.c20857734e53a3fb733b7443879efa61.min.js></script>
<script src=https://clickear.github.io/dg3/js/callouts.7723cac461d613d118ee8bb8216b9838.min.js></script>
<script>const BASE_URL="https://clickear.github.io/dg3",fetchData=Promise.all([fetch("https://clickear.github.io/dg3/indices/linkIndex.2485fbb2c82adb527e558a337cbec182.min.json").then(e=>e.json()).then(e=>({index:e.index,links:e.links})),fetch("https://clickear.github.io/dg3/indices/contentIndex.30e624b1dc583add751a4cdad2e95ccd.min.json").then(e=>e.json())]).then(([{index:e,links:t},n])=>({index:e,links:t,content:n})),render=()=>{const e=new URL(BASE_URL),t=e.pathname,n=window.location.pathname,s=t==n;addCopyButtons(),addCollapsibleCallouts(),initPopover("https://clickear.github.io/dg3",!0,!0);const o=document.getElementById("footer");if(o){const e=document.getElementById("graph-container");if(!e)return requestAnimationFrame(render);e.textContent="";const t=s&&!1;drawGraph("https://clickear.github.io/dg3",t,[{"/moc":"#4388cc"}],t?{centerForce:1,depth:-1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.5,linkDistance:1,opacityScale:3,repelForce:1,scale:1.4}:{centerForce:1,depth:1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.6,linkDistance:1,opacityScale:3,repelForce:2,scale:1.2})}},init=(e=document)=>{addCopyButtons(),addTitleToCodeBlocks(),renderMathInElement(e.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],throwOnError:!1})}</script><script>window.Million={navigate:e=>window.location.href=e,prefetch:()=>{}},window.addEventListener("DOMContentLoaded",()=>{init(),render()})</script></head><script async src="https://www.googletagmanager.com/gtag/js?id=G-11MD77L81V"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-11MD77L81V",{anonymize_ip:!1})}</script><body><div id=search-container><div id=search-space><input autocomplete=off id=search-bar name=search type=text aria-label="search any" placeholder=支持标题及全文搜索...><div id=results-container></div></div></div><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.21/dist/flexsearch.bundle.js integrity="sha256-i3A0NZGkhsKjVMzFxv3ksk0DZh3aXqu0l49Bbh0MdjE=" crossorigin=anonymous defer></script>
<script defer src=https://clickear.github.io/dg3/js/full-text-search.24827f874defbbc6d529926cbfcfb493.min.js></script><div class=singlePage><header><h1 id=page-title><a href=https://clickear.github.io/dg3>🌿 clickearの数字花园</a></h1><div class=spacer></div><div id=search-icon><p>search any</p><svg tabindex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search Icon</title><desc id="desc">Icon to open search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"/><circle cx="8" cy="8" r="7"/></g></svg></div><div class=darkmode><input class=toggle id=darkmode-toggle type=checkbox tabindex=-1>
<label id=toggle-label-light for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="dayIcon" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35"><title>Light Mode</title><path d="M6 17.5C6 16.672 5.328 16 4.5 16h-3C.672 16 0 16.672.0 17.5S.672 19 1.5 19h3C5.328 19 6 18.328 6 17.5zM7.5 26c-.414.0-.789.168-1.061.439l-2 2C4.168 28.711 4 29.086 4 29.5 4 30.328 4.671 31 5.5 31c.414.0.789-.168 1.06-.44l2-2C8.832 28.289 9 27.914 9 27.5 9 26.672 8.329 26 7.5 26zm10-20C18.329 6 19 5.328 19 4.5v-3C19 .672 18.329.0 17.5.0S16 .672 16 1.5v3C16 5.328 16.671 6 17.5 6zm10 3c.414.0.789-.168 1.06-.439l2-2C30.832 6.289 31 5.914 31 5.5 31 4.672 30.329 4 29.5 4c-.414.0-.789.168-1.061.44l-2 2C26.168 6.711 26 7.086 26 7.5 26 8.328 26.671 9 27.5 9zM6.439 8.561C6.711 8.832 7.086 9 7.5 9 8.328 9 9 8.328 9 7.5c0-.414-.168-.789-.439-1.061l-2-2C6.289 4.168 5.914 4 5.5 4 4.672 4 4 4.672 4 5.5c0 .414.168.789.439 1.06l2 2.001zM33.5 16h-3c-.828.0-1.5.672-1.5 1.5s.672 1.5 1.5 1.5h3c.828.0 1.5-.672 1.5-1.5S34.328 16 33.5 16zM28.561 26.439C28.289 26.168 27.914 26 27.5 26c-.828.0-1.5.672-1.5 1.5.0.414.168.789.439 1.06l2 2C28.711 30.832 29.086 31 29.5 31c.828.0 1.5-.672 1.5-1.5.0-.414-.168-.789-.439-1.061l-2-2zM17.5 29c-.829.0-1.5.672-1.5 1.5v3c0 .828.671 1.5 1.5 1.5s1.5-.672 1.5-1.5v-3C19 29.672 18.329 29 17.5 29zm0-22C11.71 7 7 11.71 7 17.5S11.71 28 17.5 28 28 23.29 28 17.5 23.29 7 17.5 7zm0 18c-4.136.0-7.5-3.364-7.5-7.5s3.364-7.5 7.5-7.5 7.5 3.364 7.5 7.5S21.636 25 17.5 25z"/></svg></label><label id=toggle-label-dark for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="nightIcon" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'"><title>Dark Mode</title><path d="M96.76 66.458c-.853-.852-2.15-1.064-3.23-.534-6.063 2.991-12.858 4.571-19.655 4.571C62.022 70.495 50.88 65.88 42.5 57.5 29.043 44.043 25.658 23.536 34.076 6.47c.532-1.08.318-2.379-.534-3.23-.851-.852-2.15-1.064-3.23-.534-4.918 2.427-9.375 5.619-13.246 9.491-9.447 9.447-14.65 22.008-14.65 35.369.0 13.36 5.203 25.921 14.65 35.368s22.008 14.65 35.368 14.65c13.361.0 25.921-5.203 35.369-14.65 3.872-3.871 7.064-8.328 9.491-13.246C97.826 68.608 97.611 67.309 96.76 66.458z"/></svg></label></div></header><article><h1>分布2式算法种类</h1><p class=meta>最近编辑于
Sep 26, 2022</p><ul class=tags></ul><p>#分布式</p><p>link:
<a href=http://icyfenix.cn/distribution/consensus/ rel=noopener>凤凰架构</a></p><a href=#待办列表><h2 id=待办列表><span class=hanchor arialabel=Anchor># </span>待办列表</h2></a><ul><li><a href=https://book.clickear.top/114-%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E8%AE%AE%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AE%9E%E6%88%98/index.html rel=noopener>分布式算法-极客时间</a></li></ul><a href=#常青笔记><h2 id=常青笔记><span class=hanchor arialabel=Anchor># </span>常青笔记</h2></a><ul><li>分布式写一致性级别（All、<a href=/dg3/Quorum%E6%9C%BA%E5%88%B6 rel=noopener class=internal-link data-src=/dg3/Quorum%E6%9C%BA%E5%88%B6>Quorum机制</a>、One、Any）</li><li><a class="internal-link broken">多副本</a>是分布式中的重要问题，本质上分布式就是解决<a class="internal-link broken">多副本</a>的同步问题、共识问题。</li><li><a class="internal-link broken">数据同步</a>是直接同步原始数据，<strong>状态转移</strong>。以同步为代表的数据复制方法。需要每个节点都参与同步，导致可用性太差。</li><li>主流做法，是<strong>操作转移</strong>。类型react中的增量操作。分布式一致性的解决方案是<a href=/dg3/%E7%8A%B6%E6%80%81%E6%9C%BA%E5%A4%8D%E5%88%B6 rel=noopener class=internal-link data-src=/dg3/%E7%8A%B6%E6%80%81%E6%9C%BA%E5%A4%8D%E5%88%B6>状态机复制</a>来达到的。</li><li><a href=/dg3/Quorum%E6%9C%BA%E5%88%B6 rel=noopener class=internal-link data-src=/dg3/Quorum%E6%9C%BA%E5%88%B6>Quorum机制</a> (<a class="internal-link broken">多数派</a>)：分布式节点多余一半完成了状态转换，就认为存储成功。</li></ul><a href=#分布2式算法种类><h1 id=分布2式算法种类><span class=hanchor arialabel=Anchor># </span>分布2式算法种类</h1></a><p><img src=http://image.clickear.top/20220126203536.png width=auto alt=算法></p><a href=#拜占庭问题><h3 id=拜占庭问题><span class=hanchor arialabel=Anchor># </span><a href=/dg3/%E6%8B%9C%E5%8D%A0%E5%BA%AD%E9%97%AE%E9%A2%98 rel=noopener class=internal-link data-src=/dg3/%E6%8B%9C%E5%8D%A0%E5%BA%AD%E9%97%AE%E9%A2%98>拜占庭问题</a></h3></a><p>一般而言，在可信环境（比如企业内网）中，系统具有故障容错能力就可以了，常见的算法有二阶段提交协议（2PC）、TCC（Try-Confirm-Cancel）、Paxos 算法、ZAB 协议、Raft 算法、Gossip 协议、Quorum NWR 算法。而在不可信的环境（比如有人做恶）中，这时系统需要具备拜占庭容错能力，<br>常见的拜占庭容错算法有 POW 算法、PBFT 算法。</p><a href=#一致性><h3 id=一致性><span class=hanchor arialabel=Anchor># </span><a href=/dg3/%E4%B8%80%E8%87%B4%E6%80%A7 rel=noopener class=internal-link data-src=/dg3/%E4%B8%80%E8%87%B4%E6%80%A7>一致性</a></h3></a><p>在 CAP 定理中，CAP 中的强一致性（也就是 C）是指原子一致性（也就是线性一致性）。其中，<a href=/dg3/Paxos rel=noopener class=internal-link data-src=/dg3/Paxos>Paxos</a>、<a href=/dg3/Raft rel=noopener class=internal-link data-src=/dg3/Raft>Raft</a> 能实现线性一致性，而 ZooKeeper 基于读性能的考虑，它通过 <a href=/dg3/ZAB rel=noopener class=internal-link data-src=/dg3/ZAB>ZAB</a> 协议提供的是<a href=/dg3/%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7 rel=noopener class=internal-link data-src=/dg3/%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7>最终一致性</a></p><p>在需要<a href=/dg3/%E4%B8%80%E8%87%B4%E6%80%A7#acid%e4%b8%ad%e7%9a%84%e4%b8%80%e8%87%b4%e6%80%a7-%e7%b3%bb%e7%bb%9f%e7%8a%b6%e6%80%81%e7%9a%84%e4%b8%80%e8%87%b4%e6%80%a7 rel=noopener class=internal-link data-src=/dg3/%E4%B8%80%E8%87%B4%E6%80%A7>系统状态的一致性</a>时，你可以考虑采用二阶段提交协议(<a href=/dg3/2PC rel=noopener class=internal-link data-src=/dg3/2PC>2PC</a>)、<a class="internal-link broken">TCC</a>。在需要数据访问是的强一致性时，你可考虑 <a href=/dg3/Raft rel=noopener class=internal-link data-src=/dg3/Raft>Raft</a> 算法。在可用性优先的系统，你可以采用 Gossip 协议来实现最终一致性，并实现 Quorum NWR 来提供强一致性。</p><a href=#可用性><h3 id=可用性><span class=hanchor arialabel=Anchor># </span><a href=/dg3/%E5%8F%AF%E7%94%A8%E6%80%A7 rel=noopener class=internal-link data-src=/dg3/%E5%8F%AF%E7%94%A8%E6%80%A7>可用性</a>:</h3></a><p>可用性说的是任何来自客户端的请求，不管访问哪个非故障节点，都能得到响应数据，但不保证是同一份最新数据，可用性强调的是服务可用。<br>一般来讲，采用 <a href=/dg3/Gossip rel=noopener class=internal-link data-src=/dg3/Gossip>Gossip</a> 协议实现最终一致性系统，它的可用性是最高的，因为哪怕只有一个节点，集群还能在运行并提供服务。其次是 <a href=/dg3/Paxos rel=noopener class=internal-link data-src=/dg3/Paxos>Paxos</a> 算法、<a href=/dg3/ZAB rel=noopener class=internal-link data-src=/dg3/ZAB>ZAB</a> 协议、<a href=/dg3/Raft rel=noopener class=internal-link data-src=/dg3/Raft>Raft</a> 算法、<a href=/dg3/Quorum-NWR rel=noopener class=internal-link data-src=/dg3/Quorum-NWR>Quorum NWR</a> 算法、<a href=/dg3/PBFT rel=noopener class=internal-link data-src=/dg3/PBFT>PBFT</a> 算法、<a href=/dg3/POW rel=noopener class=internal-link data-src=/dg3/POW>POW</a> 算法，它们能容忍一定数节点故障。<br>最后是二阶段提交协议、TCC，只有当所有节点都在运行时，才能工作，可用性最低。</p><a href=#性能><h3 id=性能><span class=hanchor arialabel=Anchor># </span>性能</h3></a><p>一般来讲，采用 Gossip 协议的 <a href=/dg3/AP rel=noopener class=internal-link data-src=/dg3/AP>AP</a> 型分布式系统，具备水平扩展能力，读写性能是最高的。<br>其次是 Paxos 算法、ZAB 协议、Raft 算法，因为它们都是<a href=/dg3/%E9%A2%86%E5%AF%BC%E8%80%85%E6%A8%A1%E5%9E%8B rel=noopener class=internal-link data-src=/dg3/%E9%A2%86%E5%AF%BC%E8%80%85%E6%A8%A1%E5%9E%8B>领导者模型</a>，写性能受限于领导者，读性能取决于一致性实现。<br>最后是二阶段提交协议和 <a class="internal-link broken">TCC</a>，因为在实现事务时，需要预留和锁定资源，性能相对低。</p><a href=#分布式一致性><h2 id=分布式一致性><span class=hanchor arialabel=Anchor># </span>分布式一致性</h2></a><ul><li>如何保证数据的可靠性？即存储的不丢失？但是<a class="internal-link broken">多副本</a>。即有多个机器，存储同一份数据，这涉及到如何保证数据的一致性问题。</li><li>首先，容易想到的是 <a class="internal-link broken">数据同步</a>。每当数据有变化，把变化情况在各个节点间的复制视作一种事务性的操作。即<strong>每个节点都同步成功才算成功</strong>。如<a href=/dg3/2PC rel=noopener class=internal-link data-src=/dg3/2PC>2PC</a>、<a class="internal-link broken">3PC</a>协议。即通过<a class="internal-link broken">分布式事务</a>来保证数据的同步一致性。可靠性与可用性的矛盾造成了增加机器数量反而带来可用性的降低。以同步为代表的数据复制方法，被称为<strong>状态转移</strong>（State Transfer）<ul><li>缺点: 性能差，需要每个节点都成功。可用性差。</li></ul></li><li>主流做法，平衡了可用性和可靠性。数据复制方法是以<strong>操作转移</strong>（Operation Transfer）为基础。操作</li></ul><a href=#解决方案><h3 id=解决方案><span class=hanchor arialabel=Anchor># </span>解决方案</h3></a><p>分布式一致性的一般解决方案按<a href=/dg3/%E7%8A%B6%E6%80%81%E6%9C%BA%E5%A4%8D%E5%88%B6 rel=noopener class=internal-link data-src=/dg3/%E7%8A%B6%E6%80%81%E6%9C%BA%E5%A4%8D%E5%88%B6>状态机复制</a>。通俗的说，就是每个操作都是一条操作日志。</p><a href=#一致性模型><h3 id=一致性模型><span class=hanchor arialabel=Anchor># </span>一致性模型</h3></a><a href=#弱一致性模型><h4 id=弱一致性模型><span class=hanchor arialabel=Anchor># </span>弱一致性模型</h4></a><ul><li>DNS</li><li><a href=/dg3/Gossip rel=noopener class=internal-link data-src=/dg3/Gossip>Gossip</a></li></ul><a href=#强一致性模型><h4 id=强一致性模型><span class=hanchor arialabel=Anchor># </span>强一致性模型</h4></a><p>主要思路，是全部节点都需要同意，还是多半即可(多数派模型)</p><ul><li>同步</li></ul><blockquote><ol><li>MYSQL的主从复制模型，同步复制，即从节点写入成功才算成功。</li></ol></blockquote><blockquote><ol start=2><li>异步复制，即</li></ol></blockquote><blockquote><ol start=3><li>2PC/3PC/TCC等</li></ol></blockquote><ul><li><a href=/dg3/Paxos rel=noopener class=internal-link data-src=/dg3/Paxos>Paxos</a></li><li><a href=/dg3/Raft rel=noopener class=internal-link data-src=/dg3/Raft>Raft</a>(multi paxos)</li><li><a href=/dg3/ZAB rel=noopener class=internal-link data-src=/dg3/ZAB>ZAB</a>(multi paxos的变种)</li></ul><a href=#分布式共识算法与演进><h2 id=分布式共识算法与演进><span class=hanchor arialabel=Anchor># </span>分布式共识算法与演进</h2></a><a href=#共识><h3 id=共识><span class=hanchor arialabel=Anchor># </span>共识</h3></a><p><a class="internal-link broken">共识</a>（Consensus）与<a href=/dg3/%E4%B8%80%E8%87%B4%E6%80%A7 rel=noopener class=internal-link data-src=/dg3/%E4%B8%80%E8%87%B4%E6%80%A7>一致性</a>（Consistency）的区别：</p><blockquote><p>由于翻译的关系，很多中文资料把 Consensus 同样翻译为一致性，导致网络上大量的“二手中文资料”将这两个概念混淆起来，如果你在网上看到“分布式一致性算法”，应明白其指的其实是“Distributed Consensus Algorithm”。</p></blockquote><ul><li>共识：各节点就指定值（Value）达成共识，而且达成共识后的值，就不再改变了。共识是<strong>指达成一致性的方法与过程</strong></li><li>一致性：是指写操作完成后，能否从各节点上读到最新写入的数据，如果立即能读到，就是强一致性，如果最终能读到，就是最终一致性。一致性是指数据不同副本之间的差异</li></ul><a href=#paxos的算法演进><h3 id=paxos的算法演进><span class=hanchor arialabel=Anchor># </span>paxos的算法演进</h3></a><p><img src=http://image.clickear.top/20220126145714.png width=auto alt><br><img src=http://image.clickear.top/%e5%88%86%e5%b8%83%e5%bc%8f%e7%ae%97%e6%b3%95%28Paxos%29.png width=auto alt=paxos></p><a href=#paxos><h4 id=paxos><span class=hanchor arialabel=Anchor># </span><a href=/dg3/Paxos rel=noopener class=internal-link data-src=/dg3/Paxos>Paxos</a></h4></a><p>缺点:</p><ol><li>rpc调用次数多</li><li>活锁问题。即交替进行提案。</li><li>为什么需要prepare阶段？就是因为并发问题,即多个purposer</li></ol><a href=#multipaxos><h4 id=multipaxos><span class=hanchor arialabel=Anchor># </span><a href=/dg3/MultiPaxos rel=noopener class=internal-link data-src=/dg3/MultiPaxos>MultiPaxos</a></h4></a><p>简化版本:</p><ol><li>选举 + 复制。 选举，确定出 leader。</li><li>允许多提案者</li><li>领导者选举权， 任意副本，日志提交试用异步的commit消息。日志连续性，可以允许空洞。</li></ol><a href=#raft><h4 id=raft><span class=hanchor arialabel=Anchor># </span><a href=/dg3/Raft rel=noopener class=internal-link data-src=/dg3/Raft>Raft</a></h4></a><ol><li>唯一的leader，领导者选举权，需要最新提的日志的副本。日志需要保证连续，日志提交需要靠推进commit index<br>拆分成3个子问题</li><li>领导者选举</li><li>日志复制</li><li>Safety 安全，恢复<br>角色:</li><li>leader（领导者） 2. Follower(更随者) 3. Candidate(参与者)<br>角色是动态变化的，而不是固定的。</li></ol><a href=#multipaxos-zabraft-为什么是等价算法><h4 id=multipaxos-zabraft-为什么是等价算法><span class=hanchor arialabel=Anchor># </span><a href=/dg3/MultiPaxos rel=noopener class=internal-link data-src=/dg3/MultiPaxos>MultiPaxos</a> 、<a href=/dg3/ZAB rel=noopener class=internal-link data-src=/dg3/ZAB>ZAB</a>、<a href=/dg3/Raft rel=noopener class=internal-link data-src=/dg3/Raft>Raft</a> 为什么是等价算法？</h4></a><p>核心的原理一样</p><ol><li>通过随机超时来实现无活锁的选主过程。</li><li>通过主节点来发起写操作。同时只有1个主节点。</li><li>通过心跳来检测存活性</li><li>通过
<a href=https://www.notion.so/Quorum-f31058d3ebfc4b5bb175b5181196f0a3 rel=noopener>Quorum</a>机制来保证一致性</li></ol><p><a href="https://blog.csdn.net/weixin_34401479/article/details/90588562?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0.pc_relevant_default&spm=1001.2101.3001.4242.1&utm_relevant_index=3" rel=noopener>RAFT</a></p><p>具体细节上可以有差异：<br>譬如是全部节点都能参与选主，还是部分节点能参与，<br>譬如Quorum中是众生平等还是各自带有权重，<br>譬如该怎样表示值的方式</p><p><a href=/dg3/MultiPaxos rel=noopener class=internal-link data-src=/dg3/MultiPaxos>MultiPaxos</a> 无需要求日志顺序，达成共识后，这个值不能变。<br>ZAB和Raft: “一切以领导者为准”的强领导者模型和严格按照顺序提交日志是一样的。</p><p>ZAB 协议要实现操作的顺序性，而 Raft 的设计目标，不仅仅是操作的顺序性，而是线性一致性，这两个目标，都决定了它们不能允许日志不连续，要按照顺序提交日志，那么，它们就要通过上面的方法实现日志的顺序性，并保证达成共识（也就是提交）后的日志不会再改变。</p><a href=#为什么在-multi-paxosraft-中需要状态机呢><h4 id=为什么在-multi-paxosraft-中需要状态机呢><span class=hanchor arialabel=Anchor># </span>为什么在 Multi-Paxos、Raft 中需要状态机呢？</h4></a><p>Multi-Paxos、Raft 都是共识算法，而共识算法是就一系列值达成共识的，达成共识后，这个值就不能改了。但有时候我们是需要更改数据的值的，比如 KV 存储，我们肯定需要更改指定 key（比如 X）对应的值，这时我们就可以通过状态机来解决这个问题。<br>比如，如果你想把 X 的值改为 7，那你可以提议一个新的指令“SET X = 7”，当这个指令被达成共识并提交到状态机后，你查询到的值就是 7 了，也就成功修改了 X 的值。</p><a href=#zab是基于主备模式的原子广播协议><h4 id=zab是基于主备模式的原子广播协议><span class=hanchor arialabel=Anchor># </span><a href=/dg3/ZAB rel=noopener class=internal-link data-src=/dg3/ZAB>ZAB</a>是基于主备模式的原子广播协议</h4></a><a href=#gossip-流言蜚语原来也可以实现一致性><h3 id=gossip-流言蜚语原来也可以实现一致性><span class=hanchor arialabel=Anchor># </span><a href=/dg3/Gossip rel=noopener class=internal-link data-src=/dg3/Gossip>Gossip</a> 流言蜚语，原来也可以实现一致性</h3></a><a href=#quorum-nwr-灵活的一致性><h3 id=quorum-nwr-灵活的一致性><span class=hanchor arialabel=Anchor># </span><a href=/dg3/Quorum-NWR rel=noopener class=internal-link data-src=/dg3/Quorum-NWR>Quorum NWR</a>: 灵活的一致性</h3></a><a href=#pbft-有人作恶如何达成共识><h3 id=pbft-有人作恶如何达成共识><span class=hanchor arialabel=Anchor># </span><a href=/dg3/PBFT rel=noopener class=internal-link data-src=/dg3/PBFT>PBFT</a> 有人作恶，如何达成共识？</h3></a><a href=#pow-工作量><h3 id=pow-工作量><span class=hanchor arialabel=Anchor># </span><a href=/dg3/POW rel=noopener class=internal-link data-src=/dg3/POW>POW</a> 工作量</h3></a></article><hr><div class=page-end id=footer><div class=backlinks-container><h3>反向链接</h3><ul class=backlinks><li><a href=/dg3/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/ data-ctx=分布式算法 data-src=/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA class=internal-link></a></li></ul></div><div><script src=https://cdn.jsdelivr.net/npm/d3@6.7.0/dist/d3.min.js integrity="sha256-+7jaYCp29O1JusNWHaYtgUn6EhuP0VaFuswhNV06MyI=" crossorigin=anonymous></script><h3>内部链接关系图</h3><div id=graph-container></div><style>:root{--g-node:var(--secondary);--g-node-active:var(--primary);--g-node-inactive:var(--visited);--g-link:var(--outlinegray);--g-link-active:#5a7282}</style><script src=https://clickear.github.io/dg3/js/graph.abd4bc2af3869a96524d7d23b76152c7.js></script></div></div><hr><script src=https://giscus.app/client.js data-repo=clickear/knowledge-garden data-repo-id=R_kgDOHT-NGQ data-category=主发布站的评论系统 data-category-id=DIC_kwDOHT-NGc4CQ7hg data-mapping=title data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=zh-CN crossorigin=anonymous async></script></div></body></html>