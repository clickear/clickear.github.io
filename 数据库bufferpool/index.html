<!doctype html><html lang=en><head><script async defer data-website-id=08a754c4-6690-46d7-bb80-8ff93cfa232f src=https://umami.oldwinter.top/umami.js></script><meta charset=utf-8><meta name=description content="[!TIP] 技巧💡
如何管理数据在内存与磁盘之间的移动?
[[冯诺依曼结构]]的特性，计算机是无法直接处理硬盘中的数据的，需要先将其加载到内存中。
内存和磁盘的移动，主要有2个方面。
 空间控制策略通过决定将 pages 写到磁盘的哪个位置，使得常常一起使用的 pages 能离得更近，从而提高 I/O 效率。 时间控制策略通过决定何时将 pages 读入内存，写回磁盘，使得读写的次数最小，从而提高 I/O 效率。   概念 [[frames]] DBMS 启动时会使用malloc申请一片内存区域，我们将这段内存区域分成一个个固定大小的chunk并将这块区域划分成大小相同的 pages，为了与 disk pages 区别，通常称为 [[frames]]。"><title>数据库bufferpool</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" type=image/png href=https://clickear.github.io//icon.png><link href=https://clickear.github.io/styles.b3e1e36b0403ac565c9392b3e23ef3b6.min.css rel=stylesheet><link href=https://clickear.github.io/styles/_light_syntax.86a48a52faebeaaf42158b72922b1c90.min.css rel=stylesheet id=theme-link><script src=https://clickear.github.io/js/darkmode.b3f60b41d3bdcb2b37845d5bbe5bdf9e.min.js></script>
<script src=https://clickear.github.io/js/util.9825137f5e7825e8553c68ce39ac9e44.min.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css integrity=sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js integrity=sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script>
<script src=https://unpkg.com/@floating-ui/core@0.7.3></script>
<script src=https://unpkg.com/@floating-ui/dom@0.5.4></script>
<script src=https://clickear.github.io/js/popover.abe6a51cc7138c5dff00f151dd627ad1.min.js></script>
<script src=https://clickear.github.io/js/code-title.b35124ad8db0ba37162b886afb711cbc.min.js></script>
<script src=https://clickear.github.io/js/clipboard.c20857734e53a3fb733b7443879efa61.min.js></script>
<script src=https://clickear.github.io/js/callouts.7723cac461d613d118ee8bb8216b9838.min.js></script>
<script>const BASE_URL="https://clickear.github.io/",fetchData=Promise.all([fetch("https://clickear.github.io/indices/linkIndex.9dbef2962ae9e83da719ccab1039402d.min.json").then(e=>e.json()).then(e=>({index:e.index,links:e.links})),fetch("https://clickear.github.io/indices/contentIndex.27ac6cbe2bbda1dd8dbc496e41fd8346.min.json").then(e=>e.json())]).then(([{index:e,links:t},n])=>({index:e,links:t,content:n})),render=()=>{const e=new URL(BASE_URL),t=e.pathname,n=window.location.pathname,s=t==n;addCopyButtons(),addCollapsibleCallouts(),initPopover("https://clickear.github.io",!0,!0);const o=document.getElementById("footer");if(o){const e=document.getElementById("graph-container");if(!e)return requestAnimationFrame(render);e.textContent="";const t=s&&!1;drawGraph("https://clickear.github.io",t,[{"/moc":"#4388cc"}],t?{centerForce:1,depth:-1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.5,linkDistance:1,opacityScale:3,repelForce:1,scale:1.4}:{centerForce:1,depth:1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.6,linkDistance:1,opacityScale:3,repelForce:2,scale:1.2})}},init=(e=document)=>{addCopyButtons(),addTitleToCodeBlocks(),renderMathInElement(e.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],throwOnError:!1})}</script><script>window.Million={navigate:e=>window.location.href=e,prefetch:()=>{}},window.addEventListener("DOMContentLoaded",()=>{init(),render()})</script></head><script async src="https://www.googletagmanager.com/gtag/js?id=G-11MD77L81V"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-11MD77L81V",{anonymize_ip:!1})}</script><body><div id=search-container><div id=search-space><input autocomplete=off id=search-bar name=search type=text aria-label="search any" placeholder=支持标题及全文搜索...><div id=results-container></div></div></div><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.21/dist/flexsearch.bundle.js integrity="sha256-i3A0NZGkhsKjVMzFxv3ksk0DZh3aXqu0l49Bbh0MdjE=" crossorigin=anonymous defer></script>
<script defer src=https://clickear.github.io/js/full-text-search.24827f874defbbc6d529926cbfcfb493.min.js></script><div class=singlePage><header><h1 id=page-title><a href=https://clickear.github.io/>🌿 clickearの数字花园</a></h1><div class=spacer></div><div id=search-icon><p>search any</p><svg tabindex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search Icon</title><desc id="desc">Icon to open search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"/><circle cx="8" cy="8" r="7"/></g></svg></div><div class=darkmode><input class=toggle id=darkmode-toggle type=checkbox tabindex=-1>
<label id=toggle-label-light for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="dayIcon" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35"><title>Light Mode</title><path d="M6 17.5C6 16.672 5.328 16 4.5 16h-3C.672 16 0 16.672.0 17.5S.672 19 1.5 19h3C5.328 19 6 18.328 6 17.5zM7.5 26c-.414.0-.789.168-1.061.439l-2 2C4.168 28.711 4 29.086 4 29.5 4 30.328 4.671 31 5.5 31c.414.0.789-.168 1.06-.44l2-2C8.832 28.289 9 27.914 9 27.5 9 26.672 8.329 26 7.5 26zm10-20C18.329 6 19 5.328 19 4.5v-3C19 .672 18.329.0 17.5.0S16 .672 16 1.5v3C16 5.328 16.671 6 17.5 6zm10 3c.414.0.789-.168 1.06-.439l2-2C30.832 6.289 31 5.914 31 5.5 31 4.672 30.329 4 29.5 4c-.414.0-.789.168-1.061.44l-2 2C26.168 6.711 26 7.086 26 7.5 26 8.328 26.671 9 27.5 9zM6.439 8.561C6.711 8.832 7.086 9 7.5 9 8.328 9 9 8.328 9 7.5c0-.414-.168-.789-.439-1.061l-2-2C6.289 4.168 5.914 4 5.5 4 4.672 4 4 4.672 4 5.5c0 .414.168.789.439 1.06l2 2.001zM33.5 16h-3c-.828.0-1.5.672-1.5 1.5s.672 1.5 1.5 1.5h3c.828.0 1.5-.672 1.5-1.5S34.328 16 33.5 16zM28.561 26.439C28.289 26.168 27.914 26 27.5 26c-.828.0-1.5.672-1.5 1.5.0.414.168.789.439 1.06l2 2C28.711 30.832 29.086 31 29.5 31c.828.0 1.5-.672 1.5-1.5.0-.414-.168-.789-.439-1.061l-2-2zM17.5 29c-.829.0-1.5.672-1.5 1.5v3c0 .828.671 1.5 1.5 1.5s1.5-.672 1.5-1.5v-3C19 29.672 18.329 29 17.5 29zm0-22C11.71 7 7 11.71 7 17.5S11.71 28 17.5 28 28 23.29 28 17.5 23.29 7 17.5 7zm0 18c-4.136.0-7.5-3.364-7.5-7.5s3.364-7.5 7.5-7.5 7.5 3.364 7.5 7.5S21.636 25 17.5 25z"/></svg></label><label id=toggle-label-dark for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="nightIcon" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'"><title>Dark Mode</title><path d="M96.76 66.458c-.853-.852-2.15-1.064-3.23-.534-6.063 2.991-12.858 4.571-19.655 4.571C62.022 70.495 50.88 65.88 42.5 57.5 29.043 44.043 25.658 23.536 34.076 6.47c.532-1.08.318-2.379-.534-3.23-.851-.852-2.15-1.064-3.23-.534-4.918 2.427-9.375 5.619-13.246 9.491-9.447 9.447-14.65 22.008-14.65 35.369.0 13.36 5.203 25.921 14.65 35.368s22.008 14.65 35.368 14.65c13.361.0 25.921-5.203 35.369-14.65 3.872-3.871 7.064-8.328 9.491-13.246C97.826 68.608 97.611 67.309 96.76 66.458z"/></svg></label></div></header><article><h1>数据库bufferpool</h1><p class=meta>最近编辑于
Jun 14, 2023</p><ul class=tags></ul><aside class=mainTOC><details open><summary>目录</summary><nav id=TableOfContents><ol><li><a href=#概念>概念</a><ol><li><a href=#frames>[[frames]]</a></li><li><a href=#pagetable>[[pagetable]]</a></li></ol></li><li><a href=#并发访问-加latch>并发访问？ 加[[latch]]</a></li><li><a href=#缓冲池优化>缓冲池优化</a><ol><li><a href=#多缓冲池>多缓冲池</a></li><li><a href=#预读取mmap>预读取、mmap</a></li><li><a href=#扫描共享搭顺风车>扫描共享，(搭顺风车)</a></li><li><a href=#游标共享oracle支持的基于扫描共享的技术>游标共享：Oracle支持的，基于扫描共享的技术</a></li><li><a href=#buffer-pool-bypass>Buffer Pool Bypass</a></li></ol></li><li><a href=#操作系统page缓存>操作系统page缓存</a></li><li><a href=#替换策略>替换策略</a><ol><li><a href=#替换策略重点需要处理问题>替换策略，重点需要处理问题</a></li><li><a href=#算法>算法</a></li><li><a href=#解决缓冲池污染即进阶的替换策略>解决[[缓冲池污染]],即进阶的替换策略</a></li></ol></li><li><a href=#脏页回刷>脏页回刷</a></li></ol></nav></details></aside><blockquote class=tip-callout><p>技巧💡<br>如何管理数据在内存与磁盘之间的移动?<br><a class="internal-link broken">冯诺依曼结构</a>的特性，<strong>计算机是无法直接处理硬盘中的数据的，需要先将其加载到内存中。</strong><br>内存和磁盘的移动，主要有2个方面。</p><ol><li><strong>空间控制策略</strong>通过决定将 pages 写到磁盘的<strong>哪个位置</strong>，使得常常一起使用的 pages 能离得更近，从而提高 I/O 效率。</li><li><strong>时间控制策略</strong>通过决定<strong>何时</strong>将 pages 读入内存，写回磁盘，使得读写的次数最小，从而提高 I/O 效率。</li></ol></blockquote><a href=#概念><h2 id=概念><span class=hanchor arialabel=Anchor># </span>概念</h2></a><a href=#frames><h3 id=frames><span class=hanchor arialabel=Anchor># </span><a class="internal-link broken">frames</a></h3></a><p>DBMS 启动时会使用malloc申请一片内存区域，我们将这段内存区域分成一个个固定大小的chunk并将这块区域划分成大小相同的 pages，为了与 disk pages 区别，通常称为 <strong><a class="internal-link broken">frames</a>。</strong><br>当 DBMS 请求一个 disk page 时，它首先需要被复制到 Buffer Pool 的一个 frame 中，且会把从磁盘中读取到的所有page放入到frame中。<br><img src=http://image.clickear.top/20230613165400.png width=auto alt=image.png><br>磁盘page拷贝到buffer池的frame中，这个<strong>顺序是任意的</strong>，不一定要与磁盘中page的顺序一致。同时这就是很简单的拷贝，我们暂时不考虑压缩这种问题。这个page在磁盘中是什么样的，在内存中就什么样，没任何改变。同时我们对其他可能需要的page也同样调出到内存中。</p><a href=#pagetable><h3 id=pagetable><span class=hanchor arialabel=Anchor># </span><a class="internal-link broken">pagetable</a></h3></a><p>为了管理bufferpool 中的frames, 需要<a class="internal-link broken">pagetable</a>进行记录<a class="internal-link broken">frames</a>在内存的位置，引用数量，是否是脏页等信息。<br>DBMS 会维护一个 page table，page table所做的事情：</p><ul><li>负责记录每个 page 在<strong>内存中的位置</strong>，</li><li>Dirty Flag，这个flag给我我们当我们读取到这个page后，这个page有没有被修改过，甚至还要追踪是谁进行了这项修改。<strong>脏页</strong></li><li><strong>引用计数</strong>，记录当前正在使用、正在查询该page的线程数量。如果该page还在被引用的话，我们并不想让它写回到磁盘上。</li></ul><blockquote class=tip-callout><p>page Directory与page table 有什么区别呢？💡<br><a class="internal-link broken">page directory</a>是数据库文件中page id 到page位置的映射，我们对page Directory所做的改变必须<strong>持久化</strong>，所有变更必须记录到磁盘，重启后可以让 DBMS 找的page。<br><a class="internal-link broken">pagetable</a> 是buffer池frame到硬盘page的映射，这不需要保存到磁盘上。是一种在内存中的、临时的映射表，无需在磁盘中备份。<strong>不用持久化</strong>，我们可以使用hashmap或hashtable实现。但是需要<strong>保障线程安全</strong></p></blockquote><a href=#并发访问-加latch><h2 id=并发访问-加latch><span class=hanchor arialabel=Anchor># </span>并发访问？ 加<a class="internal-link broken">latch</a></h2></a><p>当被请求的 page 不在 page table 中时，DBMS 会先申请一个 <a class="internal-link broken">latch</a>（lock 的别名），表示该 entry 被占用，然后从 disk 中读取相关 page 到 buffer pool。 在我们想做任何事之前，必须保护<a class="internal-link broken">pagetable</a>不会被其他人污染或者覆盖。所以在读写之前，都要先在<a class="internal-link broken">pagetable</a>加<a class="internal-link broken">latch</a>，如果减少<a class="internal-link broken">latch</a>竞争呢？可以和<a href=/HashMap rel=noopener class=internal-link data-src=/HashMap>HashMap</a>类似的思想，如果有多个<a class="internal-link broken">pagetable</a>的话，就可以分散<a class="internal-link broken">latch</a>竞争了。<br><img src=http://image.clickear.top/20230613172052.png width=auto alt=image.png></p><a href=#缓冲池优化><h2 id=缓冲池优化><span class=hanchor arialabel=Anchor># </span>缓冲池优化</h2></a><a href=#多缓冲池><h3 id=多缓冲池><span class=hanchor arialabel=Anchor># </span>多缓冲池</h3></a><blockquote class=tip-callout><p>为什么需要多缓冲池？减少<a class="internal-link broken">latch</a>竞争💡<br>在访问、操作数据前，需要对<a class="internal-link broken">pagetable</a>进行加锁操作，避免污染或者数据被覆盖。<br>在多个线程争抢同一个latch的情况，他们会访问同一个page表，这就会导致多核处理器没法完全利用性能。因为关键部分会有争抢。</p></blockquote><ul><li>mysql可以设置多缓冲池实例。<ul><li>通过record id进行hash，确定哪个<a href=/bufferpool rel=noopener class=internal-link data-src=/bufferpool>bufferpool</a></li><li>根据<a href=/bufferpool rel=noopener class=internal-link data-src=/bufferpool>bufferpool</a>中的<a class="internal-link broken">pagetable</a>,来确定<a class="internal-link broken">frames</a>的位置。</li></ul></li><li><img src=http://image.clickear.top/20230613175035.png width=auto alt=image.png></li></ul><a href=#预读取mmap><h3 id=预读取mmap><span class=hanchor arialabel=Anchor># </span>预读取、mmap</h3></a><p>预读取，操作系统就可以帮助我们实现这种预读取处理。用mmap</p><a href=#扫描共享搭顺风车><h3 id=扫描共享搭顺风车><span class=hanchor arialabel=Anchor># </span>扫描共享，(搭顺风车)</h3></a><blockquote class=tip-callout><p>技巧💡<br>通俗的理解为<strong>搭别人的顺风车</strong>。复用从磁盘中获取的数据用于其他查询。这和结果缓存（result caching）效果相同。通俗理解：你办事情，我在结束的地方等你，等你办好，我也用你的结果，然后去办自己的事情。</p></blockquote><a href=#游标共享oracle支持的基于扫描共享的技术><h3 id=游标共享oracle支持的基于扫描共享的技术><span class=hanchor arialabel=Anchor># </span>游标共享：Oracle支持的，基于扫描共享的技术</h3></a><a href=#buffer-pool-bypass><h3 id=buffer-pool-bypass><span class=hanchor arialabel=Anchor># </span>Buffer Pool Bypass</h3></a><p>解决问题: <a href=/%E7%BC%93%E5%86%B2%E6%B1%A0%E6%B1%A1%E6%9F%93 rel=noopener class=internal-link data-src=/%E7%BC%93%E5%86%B2%E6%B1%A0%E6%B1%A1%E6%9F%93>缓冲池污染</a>，当遇到扫描量非常大的查询时，如果将所需的 pages 从磁盘中一个一个的换入 Buffer Pool，将会造成buffer池的污染，因为这些 pages 通常只使用一次，而它们的进入将导致一些可能在未来更需要的 pages 被移除，因此一些 DBMS 做了相应的优化。<br>思路：<strong>分配一小块内存给那个线程</strong>，当他从磁盘中读取page时，不管这个page已经在buffer池中了还是不在，都要放在这一小块另开辟的内存中，当查询完成时就会释放掉这块内存，这样不会污染buffer池。<br>主流数据库都支持:<br><img src=http://image.clickear.top/20230613175501.png width=auto alt=image.png></p><a href=#操作系统page缓存><h2 id=操作系统page缓存><span class=hanchor arialabel=Anchor># </span>操作系统page缓存</h2></a><p>数据库系统有缓冲池，操作系统也有硬盘与内存之间的缓存策略，这会导致一份数据（一份磁盘page）分别在操作系统和 DMBS 中的缓冲池被缓存两次。因此大多数 DBMS 都会使用 (O_DIRECT) 来告诉操作系统不要缓存这些数据，<strong>Postgresql</strong>是主流数据库中唯一使用了操作系统page缓存得数据库。<br>为什么这样做？<br>因为我们数据库缓冲池中有一份副本，而操作系统也缓存了一份磁盘page副本，在我们更新数据库缓冲池中的page后，操作系统缓存的那份page就是旧的，这显然是一份多余的数据。作为数据库系统，我们希望自主管理我们的page，不想让操作系统掺和。</p><p>另外，不同操作系统的page缓存策略也是不同的，同一种数据库有linux也有Windows版本，为了保证跨操作系统之间的一致性，这也需要数据库自己本身来管理一切。</p><a href=#替换策略><h2 id=替换策略><span class=hanchor arialabel=Anchor># </span>替换策略</h2></a><p>当<strong>缓冲池空间不足</strong>时，读入新的 pages 之前必然需要 DBMS 从缓冲池中移除一些pages。这与操作系统中的置换算法差不多。<br>需要注意的是，</p><a href=#替换策略重点需要处理问题><h3 id=替换策略重点需要处理问题><span class=hanchor arialabel=Anchor># </span>替换策略，重点需要处理问题</h3></a><a href=#缓冲池污染><h4 id=缓冲池污染><span class=hanchor arialabel=Anchor># </span><a href=/%E7%BC%93%E5%86%B2%E6%B1%A0%E6%B1%A1%E6%9F%93 rel=noopener class=internal-link data-src=/%E7%BC%93%E5%86%B2%E6%B1%A0%E6%B1%A1%E6%9F%93>缓冲池污染</a></h4></a><p>如果写了一些需要全表扫描的查询语句（比如没有建立合适的索引或者没有<code>WHERE</code>子句的查询）。</p><a href=#预读><h4 id=预读><span class=hanchor arialabel=Anchor># </span><a href=/%E9%A2%84%E8%AF%BB rel=noopener class=internal-link data-src=/%E9%A2%84%E8%AF%BB>预读</a></h4></a><p>DBMS，会对页进行预读，这样也带来了一个问题，导致加载的页不一定都是被用到。为了区分哪些是热数据。将冷热页进行分离。预读的页，都放在冷数据区即可。</p><a href=#算法><h3 id=算法><span class=hanchor arialabel=Anchor># </span>算法</h3></a><a href=#lru><h4 id=lru><span class=hanchor arialabel=Anchor># </span><a class="internal-link broken">LRU</a></h4></a><p>最近最少使用。<br>基本思想就是<strong>追踪最后被访问的时间戳</strong>，我们仅需去看哪个时间戳最老，将其置换出去即可。<br>具体实现方面，操作系统页面置换LRU算法提到了使用栈来解决，当然这里也可以使用队列来实现，如果有人读写了这个page就将其从队列中剔除然后放在尾部，头部的page会被一个个换出。</p><a href=#clock时钟置换算法近似lru><h4 id=clock时钟置换算法近似lru><span class=hanchor arialabel=Anchor># </span>Clock（时钟置换算法，近似LRU)</h4></a><p>Clock是LRU的一种近似算法，无需追踪时间戳而是<strong>追踪标志位</strong>.<br><img src=http://image.clickear.top/20230613184440.png width=auto alt=image.png><br>最开始，被换入的内存中的page标志位都是0，一旦被访问了就将其标志位置为1。当需要换出时，就像一个钟表一样顺时针或者逆时针旋转，如果发现指向的这个page标志位为1就将它改为0，然后旋转，发现标志位是0的下一个page，就将其换出。<br><strong>无法解决</strong><a href=/%E7%BC%93%E5%86%B2%E6%B1%A0%E6%B1%A1%E6%9F%93 rel=noopener class=internal-link data-src=/%E7%BC%93%E5%86%B2%E6%B1%A0%E6%B1%A1%E6%9F%93>缓冲池污染</a>问题</p><a href=#解决缓冲池污染即进阶的替换策略><h3 id=解决缓冲池污染即进阶的替换策略><span class=hanchor arialabel=Anchor># </span>解决<a href=/%E7%BC%93%E5%86%B2%E6%B1%A0%E6%B1%A1%E6%9F%93 rel=noopener class=internal-link data-src=/%E7%BC%93%E5%86%B2%E6%B1%A0%E6%B1%A1%E6%9F%93>缓冲池污染</a>,即进阶的替换策略</h3></a><a href=#lru-k><h4 id=lru-k><span class=hanchor arialabel=Anchor># </span><a class="internal-link broken">LRU-K</a></h4></a><p>LRU-K 保存每个 page 的最后 K 次访问时间戳，利用这些时间戳来估计它们下次被访问的时间，通常 K 取 1 就能获得很好的效果。<br><img src=http://image.clickear.top/20230613184610.png width=auto alt=image.png><br><a href=/-mysql%E7%9B%AE%E5%BD%95 rel=noopener class=internal-link data-src=/-mysql%E7%9B%AE%E5%BD%95>mysql</a>的<a href=/bufferpool rel=noopener class=internal-link data-src=/bufferpool>bufferpool</a>就是使用这种方法</p><a href=#多缓存池><h4 id=多缓存池><span class=hanchor arialabel=Anchor># </span><a class="internal-link broken">多缓存池</a></h4></a><p>分散</p><a href=#优先级提示-priority-hints><h4 id=优先级提示-priority-hints><span class=hanchor arialabel=Anchor># </span>优先级提示 Priority Hints</h4></a><p>有时候 DBMS 知道每个 page 在查询执行过程中的上下文信息，因此它可以根据这些信息判断一个 page 是否重要。</p><a href=#脏页回刷><h2 id=脏页回刷><span class=hanchor arialabel=Anchor># </span>脏页回刷</h2></a><p>移除一个 dirty page 的成本要高于移除一般 page，因为前者需要写 disk，后者可以直接 drop，因此 DBMS 在移除 page 的时候也需要考虑到这部分的影响。除了直接在 Replacement Policies 中考虑，有的 DBMS 使用 <strong>Background Writing</strong> 的方式来处理。它们定期扫描 page table，发现 dirty page 就写入 disk，在 Replacement 发生时就无需考虑脏数据带来的问题。</p></article><hr><div class=page-end id=footer><div class=backlinks-container><h3>反向链接</h3><ul class=backlinks><li><a href=/cmu15445/ data-ctx=数据库bufferpool data-src=/cmu15445 class=internal-link>cmu15445</a></li></ul></div><div><script src=https://cdn.jsdelivr.net/npm/d3@6.7.0/dist/d3.min.js integrity="sha256-+7jaYCp29O1JusNWHaYtgUn6EhuP0VaFuswhNV06MyI=" crossorigin=anonymous></script><h3>内部链接关系图</h3><div id=graph-container></div><style>:root{--g-node:var(--secondary);--g-node-active:var(--primary);--g-node-inactive:var(--visited);--g-link:var(--outlinegray);--g-link-active:#5a7282}</style><script src=https://clickear.github.io/js/graph.abd4bc2af3869a96524d7d23b76152c7.js></script></div></div><hr><script src=https://giscus.app/client.js data-repo=clickear/knowledge-garden data-repo-id=R_kgDOHT-NGQ data-category=主发布站的评论系统 data-category-id=DIC_kwDOHT-NGc4CQ7hg data-mapping=title data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=zh-CN crossorigin=anonymous async></script></div></body></html>