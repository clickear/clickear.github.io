<!doctype html><html lang=en><head><script async defer data-website-id=08a754c4-6690-46d7-bb80-8ff93cfa232f src=https://umami.oldwinter.top/umami.js></script><meta charset=utf-8><meta name=description content="常青笔记  一个是 Basic Paxos 算法，描述的是多节点之间如何就**某个值（提案 Value）**达成共识； 另一个是 Multi-Paxos 思想，描述的是执行多个 Basic Paxos 实例，就一系列值达成共识。 在可靠消息通道下，即在不考虑[[拜占庭问题|消息有传递错误]]下，基于[[消息传递]]通讯模型下，分布式系统下，就某一个决议达成一致（多个的话，参考[[MultiPaxos]]） prepare阶段(只是咨询，这时候没带提案内容)，是因为有多提案者导致需要预先抢占。多提案者可以加入随机超时，来避免[[活锁]]问题 在accpet阶段，提案内容的选择，是由prepare阶段返回的promise响应来决定的。从多个决策节点的promise结果中，找到最大提案id对应的提案内容，作为提案内容。  能找到最大提案id，使用决策节点中返回的对应的提案id的提案内容。 不能找到最大提案id，则使用自己的提案内容。    重要摘要 paxos Paxos 算法是莱斯利·兰伯特(Leslie Lamport)1990 年提出的一种基于消息传递的、具有高 容错性的一致性算法。Google Chubby 的作者 Mike Burrows 说过，世上只有一种一致性算法， 那就是 Paxos，所有其他一致性算法都是 Paxos 算法的不完整版。Paxos 算法是一种公认的晦 涩难懂的算法，并且工程实现上也具有很大难度。较有名的 Paxos 工程实现有 Google Chubby、 [[ZAB]]、微信的 PhxPaxos 等。"><title>Paxos</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" type=image/png href=https://clickear.github.io//icon.png><link href=https://clickear.github.io/styles.b3e1e36b0403ac565c9392b3e23ef3b6.min.css rel=stylesheet><link href=https://clickear.github.io/styles/_light_syntax.86a48a52faebeaaf42158b72922b1c90.min.css rel=stylesheet id=theme-link><script src=https://clickear.github.io/js/darkmode.b3f60b41d3bdcb2b37845d5bbe5bdf9e.min.js></script>
<script src=https://clickear.github.io/js/util.9825137f5e7825e8553c68ce39ac9e44.min.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css integrity=sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js integrity=sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script>
<script src=https://unpkg.com/@floating-ui/core@0.7.3></script>
<script src=https://unpkg.com/@floating-ui/dom@0.5.4></script>
<script src=https://clickear.github.io/js/popover.abe6a51cc7138c5dff00f151dd627ad1.min.js></script>
<script src=https://clickear.github.io/js/code-title.b35124ad8db0ba37162b886afb711cbc.min.js></script>
<script src=https://clickear.github.io/js/clipboard.c20857734e53a3fb733b7443879efa61.min.js></script>
<script src=https://clickear.github.io/js/callouts.7723cac461d613d118ee8bb8216b9838.min.js></script>
<script>const BASE_URL="https://clickear.github.io/",fetchData=Promise.all([fetch("https://clickear.github.io/indices/linkIndex.88158c8e86275515e05d7de6432515f6.min.json").then(e=>e.json()).then(e=>({index:e.index,links:e.links})),fetch("https://clickear.github.io/indices/contentIndex.9b34fdceb9ef3f04080e4e7771441495.min.json").then(e=>e.json())]).then(([{index:e,links:t},n])=>({index:e,links:t,content:n})),render=()=>{const e=new URL(BASE_URL),t=e.pathname,n=window.location.pathname,s=t==n;addCopyButtons(),addCollapsibleCallouts(),initPopover("https://clickear.github.io",!0,!0);const o=document.getElementById("footer");if(o){const e=document.getElementById("graph-container");if(!e)return requestAnimationFrame(render);e.textContent="";const t=s&&!1;drawGraph("https://clickear.github.io",t,[{"/moc":"#4388cc"}],t?{centerForce:1,depth:-1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.5,linkDistance:1,opacityScale:3,repelForce:1,scale:1.4}:{centerForce:1,depth:1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.6,linkDistance:1,opacityScale:3,repelForce:2,scale:1.2})}},init=(e=document)=>{addCopyButtons(),addTitleToCodeBlocks(),renderMathInElement(e.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],throwOnError:!1})}</script><script>window.Million={navigate:e=>window.location.href=e,prefetch:()=>{}},window.addEventListener("DOMContentLoaded",()=>{init(),render()})</script></head><script async src="https://www.googletagmanager.com/gtag/js?id=G-11MD77L81V"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-11MD77L81V",{anonymize_ip:!1})}</script><body><div id=search-container><div id=search-space><input autocomplete=off id=search-bar name=search type=text aria-label="search any" placeholder=支持标题及全文搜索...><div id=results-container></div></div></div><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.21/dist/flexsearch.bundle.js integrity="sha256-i3A0NZGkhsKjVMzFxv3ksk0DZh3aXqu0l49Bbh0MdjE=" crossorigin=anonymous defer></script>
<script defer src=https://clickear.github.io/js/full-text-search.24827f874defbbc6d529926cbfcfb493.min.js></script><div class=singlePage><header><h1 id=page-title><a href=https://clickear.github.io/>🌿 clickearの数字花园</a></h1><div class=spacer></div><div id=search-icon><p>search any</p><svg tabindex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search Icon</title><desc id="desc">Icon to open search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"/><circle cx="8" cy="8" r="7"/></g></svg></div><div class=darkmode><input class=toggle id=darkmode-toggle type=checkbox tabindex=-1>
<label id=toggle-label-light for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="dayIcon" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35"><title>Light Mode</title><path d="M6 17.5C6 16.672 5.328 16 4.5 16h-3C.672 16 0 16.672.0 17.5S.672 19 1.5 19h3C5.328 19 6 18.328 6 17.5zM7.5 26c-.414.0-.789.168-1.061.439l-2 2C4.168 28.711 4 29.086 4 29.5 4 30.328 4.671 31 5.5 31c.414.0.789-.168 1.06-.44l2-2C8.832 28.289 9 27.914 9 27.5 9 26.672 8.329 26 7.5 26zm10-20C18.329 6 19 5.328 19 4.5v-3C19 .672 18.329.0 17.5.0S16 .672 16 1.5v3C16 5.328 16.671 6 17.5 6zm10 3c.414.0.789-.168 1.06-.439l2-2C30.832 6.289 31 5.914 31 5.5 31 4.672 30.329 4 29.5 4c-.414.0-.789.168-1.061.44l-2 2C26.168 6.711 26 7.086 26 7.5 26 8.328 26.671 9 27.5 9zM6.439 8.561C6.711 8.832 7.086 9 7.5 9 8.328 9 9 8.328 9 7.5c0-.414-.168-.789-.439-1.061l-2-2C6.289 4.168 5.914 4 5.5 4 4.672 4 4 4.672 4 5.5c0 .414.168.789.439 1.06l2 2.001zM33.5 16h-3c-.828.0-1.5.672-1.5 1.5s.672 1.5 1.5 1.5h3c.828.0 1.5-.672 1.5-1.5S34.328 16 33.5 16zM28.561 26.439C28.289 26.168 27.914 26 27.5 26c-.828.0-1.5.672-1.5 1.5.0.414.168.789.439 1.06l2 2C28.711 30.832 29.086 31 29.5 31c.828.0 1.5-.672 1.5-1.5.0-.414-.168-.789-.439-1.061l-2-2zM17.5 29c-.829.0-1.5.672-1.5 1.5v3c0 .828.671 1.5 1.5 1.5s1.5-.672 1.5-1.5v-3C19 29.672 18.329 29 17.5 29zm0-22C11.71 7 7 11.71 7 17.5S11.71 28 17.5 28 28 23.29 28 17.5 23.29 7 17.5 7zm0 18c-4.136.0-7.5-3.364-7.5-7.5s3.364-7.5 7.5-7.5 7.5 3.364 7.5 7.5S21.636 25 17.5 25z"/></svg></label><label id=toggle-label-dark for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="nightIcon" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'"><title>Dark Mode</title><path d="M96.76 66.458c-.853-.852-2.15-1.064-3.23-.534-6.063 2.991-12.858 4.571-19.655 4.571C62.022 70.495 50.88 65.88 42.5 57.5 29.043 44.043 25.658 23.536 34.076 6.47c.532-1.08.318-2.379-.534-3.23-.851-.852-2.15-1.064-3.23-.534-4.918 2.427-9.375 5.619-13.246 9.491-9.447 9.447-14.65 22.008-14.65 35.369.0 13.36 5.203 25.921 14.65 35.368s22.008 14.65 35.368 14.65c13.361.0 25.921-5.203 35.369-14.65 3.872-3.871 7.064-8.328 9.491-13.246C97.826 68.608 97.611 67.309 96.76 66.458z"/></svg></label></div></header><article><h1>Paxos</h1><p class=meta>最近编辑于
Sep 16, 2022</p><ul class=tags></ul><aside class=mainTOC><details open><summary>目录</summary><nav id=TableOfContents><ol><li><a href=#常青笔记>常青笔记</a></li><li><a href=#重要摘要>重要摘要</a><ol><li><a href=#paxos>paxos</a></li><li><a href=#算法描述>算法描述</a></li><li><a href=#联动>联动</a></li><li><a href=#basicpaxos支持多提案者带来了什么问题>basicPaxos支持多提案者，带来了什么问题？</a></li><li><a href=#缺点>缺点</a></li><li><a href=#paxos-只负责达成一个决议httpszitpubnetarticledetail48b5d9f7e0d8b72aeb2f0b26fc5818f6><a href=https://z.itpub.net/article/detail/48B5D9F7E0D8B72AEB2F0B26FC5818F6>Paxos 只负责达成一个决议？</a></a></li><li><a href=#活锁问题>活锁问题</a></li><li><a href=#paxos的算法演进->paxos的算法演进 ⭐</a></li></ol></li><li><a href=#multipaxos-zabraft-为什么是等价算法>[[MultiPaxos]] 、[[ZAB]]、[[Raft]] 为什么是等价算法？</a></li><li><a href=#资料>资料</a></li></ol></nav>字数统计 269</details></aside><a href=#常青笔记><h2 id=常青笔记><span class=hanchor arialabel=Anchor># </span>常青笔记</h2></a><ul><li>一个是 Basic Paxos 算法，描述的是多节点之间如何就**某个值（提案 Value）**达成共识；</li><li>另一个是 Multi-Paxos 思想，描述的是执行多个 Basic Paxos 实例，就<strong>一系列值</strong>达成共识。</li><li>在可靠消息通道下，即在不考虑<a href=/%E6%8B%9C%E5%8D%A0%E5%BA%AD%E9%97%AE%E9%A2%98 rel=noopener class=internal-link data-src=/%E6%8B%9C%E5%8D%A0%E5%BA%AD%E9%97%AE%E9%A2%98>消息有传递错误</a>下，基于<a class="internal-link broken">消息传递</a>通讯模型下，分布式系统下，就<strong>某一个</strong>决议达成一致（多个的话，参考<a href=/MultiPaxos rel=noopener class=internal-link data-src=/MultiPaxos>MultiPaxos</a>）</li><li>prepare阶段(只是咨询，这时候没带提案内容)，是因为有多提案者导致需要预先抢占。多提案者可以加入随机超时，来避免<a class="internal-link broken">活锁</a>问题</li><li>在accpet阶段，提案内容的选择，是由prepare阶段返回的promise响应来决定的。从多个决策节点的promise结果中，找到最大提案id对应的提案内容，作为提案内容。<ul><li>能找到最大提案id，使用决策节点中返回的对应的提案id的提案内容。</li><li>不能找到最大提案id，则使用自己的提案内容。</li></ul></li></ul><a href=#重要摘要><h2 id=重要摘要><span class=hanchor arialabel=Anchor># </span>重要摘要</h2></a><a href=#paxos><h3 id=paxos><span class=hanchor arialabel=Anchor># </span>paxos</h3></a><p>Paxos 算法是莱斯利·兰伯特(Leslie Lamport)1990 年提出的一种基于消息传递的、具有高 容错性的一致性算法。Google Chubby 的作者 Mike Burrows 说过，世上只有一种一致性算法， 那就是 Paxos，所有其他一致性算法都是 Paxos 算法的不完整版。Paxos 算法是一种公认的晦 涩难懂的算法，并且工程实现上也具有很大难度。较有名的 Paxos 工程实现有 Google Chubby、 <a href=/ZAB rel=noopener class=internal-link data-src=/ZAB>ZAB</a>、微信的 PhxPaxos 等。</p><p>Paxos 算法是用于解决什么问题的呢？Paxos 算法要解决的问题是，<strong>在分布式系统中如何就某个决议达成一致</strong>.也就是，paxos是一种共识算法。<br>paxos协议，是基于操作转移进行复制的。是在不考虑<br><a href=/%E6%8B%9C%E5%8D%A0%E5%BA%AD%E9%97%AE%E9%A2%98 rel=noopener class=internal-link data-src=/%E6%8B%9C%E5%8D%A0%E5%BA%AD%E9%97%AE%E9%A2%98>消息有传递错误</a>的情况下，基于<a class="internal-link broken">消息传递</a>通讯模型的</p><a href=#算法描述><h3 id=算法描述><span class=hanchor arialabel=Anchor># </span>算法描述</h3></a><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>这里介绍的算法描述，都是BasicPaxos。其它类MultiPaxos参考paxos算法演进
</span></span></code></pre></td></tr></table></div></div><a href=#前置条件><h4 id=前置条件><span class=hanchor arialabel=Anchor># </span>前置条件</h4></a><ul><li>Paxos 只负责达成一个决议。</li><li>唯一的递增的提案id号</li><li>一个提案 = 提案id + 提案value。prepare只会带有提案id，申请锁定。</li><li>每个表决者在 accept 某提案后，会将该提案的编号 N 记录在本地，这样每个表决者中 保存的已经被 accept 的提案中会存在一个编号最大的提案，其编号假设为 maxN。每个表决者仅会 accept 编号大于自己本地 maxN 的提案。</li><li>在众多提案中最终只能有一个提案被选定。</li><li>一旦一个提案被选定，则其它服务器会主动同步(Learn)该提案到本地。 没有提案被提出则不会有提案被选定。</li></ul><a href=#角色><h4 id=角色><span class=hanchor arialabel=Anchor># </span>角色</h4></a><p>在 Paxos 算法中有三种角色，分别具有三种不同的行为。但很多时候，一个进程可能同 时充当着多种角色。</p><ul><li>Proposer：提案（Proposal）的提案者。在一个集群中，提案者可能存在多个，不同的提案者会提出不同的提案。</li><li>Acceptor：提案的表决者。即用于表决是否同步某提案。只有过半的 Acceptor 接受了某提案，该提案才会被认为是“选定了”。</li><li>Learner(也可以理解为记录)：提案的同步者。当提案被选定时，其要在本地执行该提案内容。</li></ul><a href=#流程-><h4 id=流程-><span class=hanchor arialabel=Anchor># </span>流程 ⭐</h4></a><p>Paxos 算法包括两个阶段，其中prepare阶段和accept阶段。所以至少需要2次rpc调用。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>为什么需要prepare阶段？
</span></span><span class=line><span class=cl>是因为basic-paxos是支持多个提案者的，也就是每个提案者只有会有一个值的不同提案。
</span></span></code></pre></td></tr></table></div></div><p><img src=http://image.clickear.top/20220127111029.png width=auto alt="Paxos 算法整体时序图"></p><a href=#prepare阶段><h4 id=prepare阶段><span class=hanchor arialabel=Anchor># </span>prepare阶段</h4></a><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>prepare，是为了抢占。每个决策节点本地会记录一个最大的提案号localMaxN。提案节点，发起prepare节点，只接受最新请求。prepare阶段，请求中不待提案内容，只有提案id。只处理最新的提案。旧的直接废弃。接受到prepare后，更新本地的 localMaxN = N;
</span></span></code></pre></td></tr></table></div></div><p>第一阶段“准备”（Prepare）就
<a href=http://icyfenix.cn/distribution/consensus/paxos.html rel=noopener>相当于上面抢占锁的过程</a>。如果某个提案节点准备发起提案，必须先向所有的决策节点广播一个许可申请（称为 Prepare 请求）。提案节点的 Prepare 请求中会附带一个全局唯一的递增的数字 n 作为提案 ID，决策节点收到后，将会给予提案节点两个承诺与一个应答。<br>两个承诺是指：</p><ul><li>承诺不会再接受提案 ID 小于或等于 n 的 Prepare 请求。</li><li>承诺不会再接受提案 ID 小于 n 的 Accept 请求。<br>一个应答是指：</li><li>不违背以前作出的承诺的前提下，回复已经批准过的提案中 ID 最大的那个提案所设定的值和提案 ID，如果该值从来没有被任何提案设定过，则返回空值。如果违反此前做出的承诺，即收到的提案 ID 并不是决策节点收到过的最大的，那允许直接对此 Prepare 请求不予理会</li></ul><a href=#accept阶段><h4 id=accept阶段><span class=hanchor arialabel=Anchor># </span>accept阶段</h4></a><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>1. accpet阶段，最重要的就是从决策节点的响应中(会返回promise(id,value))，**获取到提案id最大的提案id。然后把对应的maxAcceptValue作为提案内容**。而不管之前的提案内容，这样就可以保证一致性，如果没找到最大的提案id，就以自己为准。
</span></span><span class=line><span class=cl>2. 决策节点，接受到accept后，以本地的提案id进行比较，判断是不是之前抢占的。如果是则更新成功。否则就不处理。
</span></span><span class=line><span class=cl>3. 当提案节点收到了多数派决策节点的应答（称为 Accepted 应答）后，协商结束，共识决议形成，将形成的决议发送给所有记录节点进行学习
</span></span></code></pre></td></tr></table></div></div><p>当提案节点收到了多数派决策节点的应答（称为 Promise 应答）后，可以开始第二阶段“批准”（Accept）过程，这时有如下两种可能的结果：</p><ul><li>如果提案节点发现所有响应的决策节点此前都没有批准过该值（即为空），那说明它是第一个设置值的节点，可以随意地决定要设定的值，将自己选定的值与提案 ID，构成一个二元组“(id, value)”，再次广播给全部的决策节点（称为 Accept 请求）。</li><li>如果提案节点发现响应的决策节点中，已经有至少一个节点的应答中包含有值了，那它就不能够随意取值了，必须无条件地从应答中找出提案 ID 最大的那个值并接受，构成一个二元组“(id, maxAcceptValue)”，再次广播给全部的决策节点（称为 Accept 请求）。<br>当每一个决策节点收到 Accept 请求时，都会在不违背以前作出的承诺的前提下，接收并持久化对当前提案 ID 和提案附带的值。如果违反此前做出的承诺，即收到的提案 ID 并不是决策节点收到过的最大的，那允许直接对此 Accept 请求不予理会。<br>当提案节点收到了多数派决策节点的应答（称为 Accepted 应答）后，协商结束，共识决议形成</li></ul><a href=#例子><h5 id=例子><span class=hanchor arialabel=Anchor># </span>例子</h5></a><a href=#以决策节点返回的最大提案id的内容为准><h5 id=以决策节点返回的最大提案id的内容为准><span class=hanchor arialabel=Anchor># </span>以决策节点返回的最大提案id的内容为准</h5></a><p><img src=http://image.clickear.top/20220127104814.png width=auto alt="X 被选定只取决于 Promise 应答中是否已批准"><br>X 被选定为最终值并不是必定需要多数派的共同批准，只取决于 S5提案时 Promise 应答中是否已包含了批准过 X 的决策节点，譬如图 6-3 所示，S5发起提案的 Prepare 请求时，X 并未获得多数派批准，但由于 S3已经批准的关系，最终共识的结果仍然是 X。</p><hr><a href=#决策节点的acceptaccept的提案id大于本地的localmaxn><h5 id=决策节点的acceptaccept的提案id大于本地的localmaxn><span class=hanchor arialabel=Anchor># </span>决策节点的accept，accept的提案id大于本地的localMaxN</h5></a><p><img src=http://image.clickear.top/20220127104538.png width=auto alt="整个系统最终会对“取值为 Y”达成一致"><br>S5提案时 Promise 应答中并未包含批准过 X 的决策节点，譬如应答 S5提案时，节点 S1已经批准了 X，节点 S2、S3未批准但返回了 Promise 应答，此时 S5以更大的提案 ID 获得了 S3、S4、S5的 Promise，这三个节点均未批准过任何值，那么 S3将不会再接收来自 S1的 Accept 请求，因为它的提案 ID 已经不是最大的了</p><a href=#联动><h3 id=联动><span class=hanchor arialabel=Anchor># </span>联动</h3></a><a href=#basicpaxos支持多提案者带来了什么问题><h3 id=basicpaxos支持多提案者带来了什么问题><span class=hanchor arialabel=Anchor># </span>basicPaxos支持多提案者，带来了什么问题？</h3></a><ol><li>多提案者，带来了并发问题，即可能同时存在多个不同提案。存在并发问题。存在并发，就需要抢占锁。</li><li>多个提案者，就存在<a class="internal-link broken">活锁</a>问题。在算法实现中会引入<strong>随机超时</strong>时间来避免活锁的产生</li></ol><a href=#缺点><h3 id=缺点><span class=hanchor arialabel=Anchor># </span>缺点</h3></a><h3 id=paxos-只负责达成一个决议httpszitpubnetarticledetail48b5d9f7e0d8b72aeb2f0b26fc5818f6><a href=https://z.itpub.net/article/detail/48B5D9F7E0D8B72AEB2F0B26FC5818F6 rel=noopener>Paxos 只负责达成一个决议？</a></h3><p>paxos只负责达成一个提案，一旦达成之后，其他的proposer就没有办法修改了，也就是说其他 proposer 再怎么重复的提交 propose，都只会学习到已经达成一致的 Value 值，然后重复提交：比如说多一个人决议去哪里吃饭，有些人是 proposer，所有人都是 acceptor，这些 proposer 都提除不同的吃饭地点，然后发表提案，最终paxos 达成吃饭地点的提案就可以了。如果是多个不同的提案都需要做，实际上 paxos 并没有定义如何去实现，这是 <a href=/MultiPaxos rel=noopener class=internal-link data-src=/MultiPaxos>MultiPaxos</a> 做的事情</p><a href=#活锁问题><h3 id=活锁问题><span class=hanchor arialabel=Anchor># </span>活锁问题</h3></a><p>活锁指的是任务或者执行者没有被阻塞，由于某些条件没有满足，导致一直重复“尝试 —失败—尝试—失败”的过程。处于活锁的实体是在不断的改变状态，活锁有可能自行解开。<br>活锁与死锁的状态有着本质的区别：</p><ol><li>活锁是一直在动，是活动状态。</li><li>死锁是系统阻塞，是不活动状态</li></ol><p><img src=http://image.clickear.top/20220127104344.png width=auto alt=批准阶段失败，形成活锁><br>P是prepare。 A是accept<br>如果两个提案节点交替使用更大的提案 ID 使得准备阶段成功，但是批准阶段失败的话，这个过程理论上可以无限持续下去，形成活锁（Live Lock</p><a href=#paxos的算法演进-><h3 id=paxos的算法演进-><span class=hanchor arialabel=Anchor># </span>paxos的算法演进 ⭐</h3></a><p><img src=http://image.clickear.top/20220126145714.png width=auto alt><br><img src=http://image.clickear.top/%e5%88%86%e5%b8%83%e5%bc%8f%e7%ae%97%e6%b3%95%28Paxos%29.png width=auto alt=paxos></p><a href=#multipaxos-zabraft-为什么是等价算法><h2 id=multipaxos-zabraft-为什么是等价算法><span class=hanchor arialabel=Anchor># </span><a href=/MultiPaxos rel=noopener class=internal-link data-src=/MultiPaxos>MultiPaxos</a> 、<a href=/ZAB rel=noopener class=internal-link data-src=/ZAB>ZAB</a>、<a href=/Raft rel=noopener class=internal-link data-src=/Raft>Raft</a> 为什么是等价算法？</h2></a><p>核心的原理一样</p><ol><li>通过随机超时来实现无活锁的选主过程。</li><li>通过主节点来发起写操作。同时只有1个主节点。</li><li>通过心跳来检测存活性</li><li>通过
<a href=https://www.notion.so/Quorum-f31058d3ebfc4b5bb175b5181196f0a3 rel=noopener>Quorum</a>机制来保证一致性</li></ol><p><a href="https://blog.csdn.net/weixin_34401479/article/details/90588562?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0.pc_relevant_default&spm=1001.2101.3001.4242.1&utm_relevant_index=3" rel=noopener>RAFT</a></p><p>具体细节上可以有差异：<br>譬如是全部节点都能参与选主，还是部分节点能参与，<br>譬如Quorum中是众生平等还是各自带有权重，<br>譬如该怎样表示值的方式</p><a href=#资料><h2 id=资料><span class=hanchor arialabel=Anchor># </span>资料</h2></a><p><a href=https://z.itpub.net/article/detail/48B5D9F7E0D8B72AEB2F0B26FC5818F6 rel=noopener>共识算法 之 Basic Paxos</a> ⭐</p><p><a href=https://blog.openacid.com/algo/paxos/ rel=noopener>可靠分布式系统-paxos的直观解释 - OpenACID Blog</a></p></article><hr><div class=page-end id=footer><div class=backlinks-container><h3>反向链接</h3><ul class=backlinks><li><a href=/%E6%8B%9C%E5%8D%A0%E5%BA%AD%E9%97%AE%E9%A2%98/ data-ctx=Paxos data-src=/%E6%8B%9C%E5%8D%A0%E5%BA%AD%E9%97%AE%E9%A2%98 class=internal-link></a></li><li><a href=/-%E5%88%86%E5%B8%83%E5%BC%8F%E7%AE%97%E6%B3%95/ data-ctx=Paxos data-src=/-%E5%88%86%E5%B8%83%E5%BC%8F%E7%AE%97%E6%B3%95 class=internal-link>分布2式算法种类</a></li><li><a href=/MultiPaxos/ data-ctx="basic paxos" data-src=/MultiPaxos class=internal-link></a></li></ul></div><div><script src=https://cdn.jsdelivr.net/npm/d3@6.7.0/dist/d3.min.js integrity="sha256-+7jaYCp29O1JusNWHaYtgUn6EhuP0VaFuswhNV06MyI=" crossorigin=anonymous></script><h3>内部链接关系图</h3><div id=graph-container></div><style>:root{--g-node:var(--secondary);--g-node-active:var(--primary);--g-node-inactive:var(--visited);--g-link:var(--outlinegray);--g-link-active:#5a7282}</style><script src=https://clickear.github.io/js/graph.abd4bc2af3869a96524d7d23b76152c7.js></script></div></div><hr><script src=https://giscus.app/client.js data-repo=clickear/knowledge-garden data-repo-id=R_kgDOHT-NGQ data-category=主发布站的评论系统 data-category-id=DIC_kwDOHT-NGc4CQ7hg data-mapping=title data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=zh-CN crossorigin=anonymous async></script></div></body></html>